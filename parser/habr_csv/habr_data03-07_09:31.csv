post_id'post_id'title'description'source_link'body'image'images
0'720868'Корутины в UnrealEngine'Привет, Хабр! На дворе уже 2023 год, а значит пора использовать новшества C++20 и в геймдеве по полной. В этой статье я расскажу, как можно улучшить читаемость асинхронного кода и сократить немалое,...'https://habr.com/ru/post/720868/'"Привет, Хабр!

На дворе уже 2023 год, а значит пора использовать новшества C++20 и в геймдеве по полной.

В этой статье я расскажу, как можно улучшить читаемость асинхронного кода и сократить немалое, на мой взгляд, количество писанины. И это благодаря такой возможности стандарта уже минувшего года, как сопрограммы. На Хабре опубликовано некоторое количество статей об этой интересной языковой технологии, но я хочу показать практическое применение в проектах UnrealEngine, а так же приоткрыть завесу сопрограмм для тех, кто ещё не в курсе.

Статья ориентирована на любознательных разработчиков гейм индустрии, работающих в UnrealEngine. Не важно, имели ли вы какой-либо опыт с сопрограммами ранее. Я хочу показать как с этим работать в этом прекрасном игровом движке, ведь в том же Unity давно существует подобное и является довольно ходовым инструментом.

Но хочу сразу предупредить, что статья явно не подходит тем, кто совсем недавно перешел из Blueprint в C++ будучи новичком. В статье много шаблонного кода, который неподготовленному читателю может показаться попросту непонятным.

Если вас не интересует внутреннее устройство сопрограмм, можете пропустить главы ""Создаём собственную реализацию сопрограмм"" и ""Future"", всегда можно посмотреть на примеры и воспользоваться готовым кодом. Ссылка на github в конце статьи.

Введение

Сопрограмма (корутина, coroutine) - это такая функция, которая может приостанавливать своё выполнение и возобновлять его при наступлении некоторого события. Данная возможность существует уже давно во многих языках. Сопрограммы в C++ и некоторых других языках, например Python, можно разделить на два типа:

Генератор - функция-сопрограмма, которую мы возобновляем сами, например с шагом цикла, а оператор yield возвращает значение, прерывая сопрограмму.

Асинхронная функция (задача, таск) - функция-сопрограмма, которая передаёт своё управление другой сопрограмме при помощи оператора await , при этом первая сопрограмма прерывается, а другая начинает своё выполнение.

В статье я затрону только второй тип, так как это наиболее интересно при написании асинхронного кода в UnrealEngine.

А что является сопрограммой в C++?

В C++ сопрограммой становится любая функция, в теле которой упомянули хотя бы одно из перечисленных ключевых слов языка C++: co_yield , co_await , co_return . При этом важно, чтобы тип возвращаемого значения этой функции отвечал некоторым требованиям, о которых мы поговорим позже. Но сначала вернёмся к UnrealEngine.

Асинхронность в UnrealEngine

Среди наиболее распространенных примеров асинхронности в UnrealEngine можно выделить следующие:

Таймеры, задержки

Загрузка ассетов с диска (Soft Object Pointers)

Вызов GameplayTask'ов (Gameplay Ability System, AI)

Обращение к веб-сервису через модуль HTTP

Ожидание условий (Latent Actions)

Асинхронный код на UnrealEngine, как правило, использует делегаты как callbacks (делегаты по сути хранят указатели на функции и опционально объекты, на которых они вызываются функции-члены). Типичный асинхронный код на примере таймеров выглядит таким образом:

void UMyClass::Foo() { FTimerHandle TimerHandle; FTimerDelegate TimerDelegate = FTimerDelegate::CreateUObject(this, &ThisClass::Bar); GetWorld()->GetTimerManager().SetTimer(TimerHandle, TimerDelegate, 5.f); } void UMyClass::Bar() { UE_LOG(LogTemp, Log, TEXT(""Hello from Bar"")); }

Данный код вызывает функцию Bar через 5 секунд. Знатоки скажут, что для данного случая делегаты вовсе не обязательно использовать, однако, раз я заговорил о делегатах, то начну именно с такого примера. И так или иначе под капотом всё равно будут делегаты, просто иногда удаётся их скрыть от пользователя, но указатель на метод класса всё равно придётся делать:

FTimerHandle TimerHandle; GetWorld()->GetTimerManager().SetTimer(TimerHandle, this, &ThisClass::Bar, 5.f); // Под капотом перегрузка функции SetTimer всё равно использует делегат

Использование делегатов также позволяет пробрасывать в вызываемую позже функцию некоторые дополнительные данные, что даёт нам возможность принять информацию в этой функции оттуда, где этот делегат был создан - поведение аналогично std::bind :

void UMyClass::Foo() { FTimerHandle TimerHandle; FString MyName = TEXT(""Vasya Pupkin""); FTimerDelegate TimerDelegate = FTimerDelegate::CreateUObject(this, &ThisClass::Bar, MyName); GetWorld()->GetTimerManager().SetTimer(TimerHandle, TimerDelegate, 5.f); } void UMyClass::Bar(FString Name) { UE_LOG(LogTemp, Log, TEXT(""Hello from Bar, %s""), *Name); }

А можно не заморачиваться и вовсе использовать лямбду, тогда можно просто захватить эти данные в Capture List:

void UMyClass::Foo() { FTimerHandle TimerHandle; FString MyName = TEXT(""Ivan""); auto Bar = [MyName] { UE_LOG(LogTemp, Log, TEXT(""Hello from Bar, %s""), *MyName); }; FTimerDelegate TimerDelegate = FTimerDelegate::CreateWeakLambda(this, Bar); GetWorld()->GetTimerManager().SetTimer(TimerHandle, this, &ThisClass::Bar, 5.f); }

Всё это очень утомляет: делегаты, лямбды, пробрасывание параметров. И по сей день, на моей практике, вариантов других при разработке на UnrealEngine я не находил. Мы можем, конечно, использовать Blueprint: там есть нода Delay , которая приостанавливает выполнение потока* выполнения блупринта, а как только проходит время, он возобновляется. Ничего не напоминает? Могли бы мы сделать так же, но в C++? Легко, следите за пальцами:

TAsyncTask<> UMyClass::Foo() { FString MyName = TEXT(""Ivan""); co_await Delay(this, 5.f); UE_LOG(LogTemp, Log, TEXT(""Hello from Bar, %s""), *MyName); }

Код не раздробился на колбеки! Все делегаты исчезли! На самом деле не исчезли, просто их теперь не видно, но нам и не надо теперь их видеть.

* - Поток - не тот поток, который принадлежит CPU. В контексте UnrealEngine Blueprint поток (Flow) - течение выполнения кода в виртуальной машине Blueprint. Так как у движка есть свой Event Loop, при каком-либо прерывании кода в Blueprint, будь то Delay или другой Latent Action, это течение просто на время перестаёт выходит из этого блупринта, а потом возвращается по истечении некоторого времени. За это время могут быть выполнены другие действия, но все они будут в пределах одного потока CPU.

Включение использования сопрограмм в ваш проект

По умолчанию, по крайней мере UnrealEngine 5.1, использует C++17, а сопрограммы в стандарте официально представлены в C++20. К счастью вам необязательно переключать стандарт для этих целей на C++20. 17-го вполне достаточно, так как этот стандарт предоставляет сопрограммы на экспериментальном уровне. Хотя на моём опыте разницы особой нет, но если вы знаете фундаментальную разницу, напишите в комментариях.

Первое, что мы должны сделать, так это найти ваш ProjectName.Target.cs файл и прописать туда код, включающий сопрограммы в вашем проекте. Делается это с помощью флага bEnableCppCoroutinesForEvaluation = true; .

Как мы видим, разработчики UnrealEngine с настороженностью относятся к использованию сопрограмм, и как бы намекает вам названием этой опции. К тому же будет выведено сообщение в логе сборки:

NOTE: C++ coroutine support is considered experimental and should be used for evaluation purposes only (bEnableCppCoroutinesForEvaluation)

Если не определились между C++17 и C++20 В зависимости от выбранного стандарта, нам понадобится некоторое ветвление в исходном коде: #if __has_include(<coroutine>) #include <coroutine> #elif __has_include(<experimental/coroutine>) #include <experimental/coroutine> namespace std { using std::experimental::coroutine_handle; using std::experimental::suspend_always; using std::experimental::suspend_never; } #else #error ""Coroutines not supported"" #endif Таким образом мы предусмотрели оба стандарта в одном файле, где мы собираемся писать наши сопрограммы. Ну и заодно сообщим программисту ошибку, если он вдруг решил использовать сопрограммы в более раннем стандарте.

Создаём собственную реализацию сопрограмм

Что в действительности происходит в коде, когда мы доходим до co_await Delay(this, 5.f) ? Чтобы ответить на этот вопрос, постараюсь вкратце изложить как создать свой собственный класс сопрограммы. Я не буду углубляться в супер-дебри сопрограмм (их там и достаточно), но общую информацию постараюсь передать для читателя. Сразу предупреждаю, что дальше будет непростой для понимания шаблонный код, такова природа сопрограмм. Но надеюсь, что смогу передать свои знания настолько чисто, насколько это возможно. И, конечно же, это не является учебным пособием как именно писать классы сопрограмм. Я лишь делюсь своим собственным кейсом использования и реализации.

Давайте для начала поговорим об обещаниях (promise, промиз).

Promise - это такой объект, который участвует в управлении поведением сопрограммы, он предоставляет некое API, методы которого вызываются в некоторые моменты во время выполнения сопрограммы. И нас интересуют следующие методы:

return_void - метод, который будет вызван, когда сопрограмма завершилась и вернула void.

return_value - аналогично return_void, но при завершении вернула значение конкретного типа.

initial_suspend - функция, которая возвращает awaitable объект, который будет вызван при входе в сопрограмму.

final_suspend - аналогично initial_suspend, но при выходе из сопрограммы.

get_return_object - возвращает такой объект, который был использован на месте в коде, где мы воспользовались co_await , то есть на вызывающей стороне.

Мы хотим, чтобы наша сопрограмма всегда приостанавливалась при входе в неё (для ожидания дальнейших условий) и никогда не приостанавливалась при выходе из неё. В таких случаях есть специально заготовленные awaitable-объекты из стандартной библиотеки: std::suspend_always и std::suspend_never . В других сценариях возможны и другие варианты, но мы остановимся именно на этом, универсальном на мой взгляд, в данных задачах.

Так же мы хотим определить некоторый делегат, который будет вызываться, когда сопрограмма будет заканчивать своё выполнение. А заканчивает своё выполнение сопрограмма либо на return_value , либо на return_void , там то мы и пристроим вызов делегата. Чтобы понять цель этого делегата, мы ещё вернёмся к нему позже. Просто рассуждайте пока так, что вызов данного делегата будет побуждать продолжение другой сопрограммы, которая вызвала текущую сопрограмму.

// Общая реализация template<typename ReturnType> struct TPromise_Base { DECLARE_DELEGATE_OneParam(FOnDone, ReturnType); FOnDone OnDone; void return_value(ReturnType Result) { OnDone.ExecuteIfBound(Result); } }; // Специализация для void template<> struct TPromise_Base<void> { DECLARE_DELEGATE(FOnDone); FOnDone OnDone; void return_void() const { OnDone.ExecuteIfBound(); } };

Почему бы не сделать один класс? Зачем специализация? Это запрещено. Даже SFINAE не решит данную ситуацию. Специализация обязательна, такова специфика работы компилятора при использовании оператора co_return .

Как можно заметить, мы разделили реализацию для void и возвращаемого значения. Теперь мы можем выбирать одну из этих двух специализаций в зависимости от того, есть ли необходимость в возвращаемом значении и сделаем обобщение в один класс:

template<typename ReturnType, typename TaskType> struct TPromise : TPromise_Base<ReturnType, TaskType> { using Super = TPromise_Base<ReturnType, TaskType>; auto initial_suspend() const noexcept { return std::suspend_always(); } auto final_suspend() const noexcept { return std::suspend_never(); } auto get_return_object() const noexcept { return static_cast<TaskType>(TaskType::HandleType::from_promise(*this)); } Super::FOnDone& GetOnDoneEvent() { return Super::OnDone; } };

Довольно много вопросов вызывает get_return_object . Здесь какой-то странный каст, да ещё какой-то параметр шаблона, о котором мы не говорили - TaskType .

Дело в том, что данный Promise будет принадлежать задаче (Task), о которой мы поговорим ниже. А функция from_promise создаёт этот Task (вызывает конструктор), потому что он был заявлен как возвращаемое значение у сопрограммы.

Что должно быть в Task? Вот список необходимого API, который должна предоставлять задача:

await_ready - функция определяет, должна ли происходить приостановка сопрограммы при ожидании данного объекта (при вызове оператора co_await на данном объекте)

await_resume - данная функция вызывается автоматически, при возобновлении приостановленной сопрограммы, она должна возвращать значение или void в зависимости от требований. И возвращает его она туда, где было произведена остановка. И результат этой функции будет чему-то присвоен, а именно выражению до co_await .

await_suspend - данная функция вызывается автоматически при остановке сопрограммы. Здесь мы можем выполнить некоторые действия, которые в дальнейшем могут привести к побуждению возобновления текущей сопрограммы. Так же данная функция принимает в качестве параметра специальный объект типа std::coroutine_handle , который и является интерфейсом управления самой сопрограммой.

Так же стоит упомянуть тип, который должен обязательно находиться в теле класса - это promise_type . Данный тип будет использоваться, когда будет запускаться сопрограмма. Компилятор автоматически создаёт Promise этого типа, когда мы входим в сопрограмму.

И ещё пару слов о std::coroutine_handle . Когда мы входим в сопрограмму, всегда создаётся объект такого типа. Это ничто иное, как интерфейс взаимодействия с сопрограммой, именно с помощью этого объекта мы можем возобновлять выполнение сопрограммы (см. метод resume или оператор () ).

Аналогично Promise, мы разделяем класс для void и для возвращаемого значения:

// Общая реализация (с возвращаемым значением) template<typename R> struct TTask_Base { TOptional<R> Result; }; // Специализация, если у нас void template<> struct TTask_Base<void> { bool bIsFinished; };

Здесь я использую TOptional , чтобы хранить возвращаемое значение. В момент, когда задача запущена, очевидно готового значения мы ещё не имеем. В случае void, нам лишь достаточно знать, задача закончилась или нет.

Перейдём к описанию главного класса задачи:

template<typename R = void> struct TTask : TTask_Base<R> { using ReturnType = R; public: // Алиас для доступа к родительским полям using Super = TTask_Base<R>; // Это - необходимый тип, он используется компилятором для создания инстанса Promise using promise_type = TPromise<ReturnType, TTask<R>>; // Тип хэндла сопрограммы всегда должен содержать в качестве шаблонного параметра promise_type using HandleType = std::coroutine_handle<promise_type>; TTask(HandleType InHandle = nullptr) : Handle(InHandle) , bLaunched(false) { } Super::FOnDone& GetOnDone() const { return Handle.promise().GetOnDoneEvent(); } bool await_ready() { return false; } // Вызывается при возобновлении работы сопрограммы ReturnType await_resume() { if constexpr (TIsSame<R, void>::Value) { return; // возобновление предусматривает возврат void } else { ReturnType Value = Super::Result.GetValue(); return Value; // либо возврат значения (результата выпонения задачи) } } // Вызывается при остановке сопрограммы // В этом случае мы имеем доступ к интерфейсу сопрограммы, который передаётся в качестве параметра template<typename P> void await_suspend(std::coroutine_handle<P> Continuation) { auto& Promise = Handle.promise(); // Через этот интерфейс мы можем получить само обещание if constexpr (TIsSame<R, void>::Value) { // Мы подписываемся на делегат при остановке, чтобы при вызове этого делегата, произошло возобновление сопрограммы Promise.OnDone.BindLambda([this, Continuation] { TTask_Base<R>::bIsFinished = true; Continuation.resume(); // при вызове этой функции, мы непременно возобновляем сопрограмму }); } else { Promise.OnDone.BindLambda([this, Continuation] (R InResult) { TTask_Base<R>::Result = InResult; Continuation.resume(); }); } } // С помощью данной функции мы запускаем приостановленную ранее (в момент initial_suspend) сопрограмму bool Launch() { check(Handle != nullptr); const bool bWasLaunched = bLaunched; bLaunched = true; if ensureMsgf(!bWasLaunched, TEXT(""Task already launched"")) { Handle.resume(); } return bLaunched; } // Данный оператор вызывается в самый первый момент, когда мы используем co_await // Здесь мы можем сделать какие-либо предварительные действия auto& operator co_await() { Launch(); // В данном случае мы хотим запустить приостановленную сопрограмму return *this; } protected: // Хэндл самой сопрограммы. Мы его храним для дальнейших взаимодействий с ней HandleType Handle; bool bLaunched; };

Здесь приведен довольно большой кусок кода и, чтобы его переварить, нужно немножко отпотеть. Но в целом этого уже достаточно, чтобы писать свои таски. Но нам предстоит разобраться ещё с одним интересным классом: фьючер (Или фьючерс? Поправьте меня). Буду писать просто по-английски - Future.

Future

Future - это, как и задача, awaitable объект, но, в отличие от задачи, это лишь объект, который необходим, чтобы побудить возобновление сопрограммы позже и передать ей некоторый результат в момент возобновления.

А что же такое awaitable объект? Объект является awaitable, если он используется в co_await -выражении. То есть это такой объект, который мы можем ожидать, пока какая-либо внешняя логика не подаст сигнал о продолжении

Как и в случае задачи, мы должны предоставить со стороны Future некоторый API (типичный awaitable-объект):

await_ready - можно ли возобновлять сопрограмму? Если false, то произойдет приостановка, если true, то продолжится выполнение

await_suspend - действие, выполняемое при остановке сопрограммы

await_resume - действие, выполняемое при возобновлении сопрограммы, здесь мы обязаны вернуть некоторый результат, либо void (в зависимости от типа)

// База, храним общую информацию struct FFuture_Base { bool await_ready() { return false; } template<typename PromiseType> void await_suspend(std::coroutine_handle<PromiseType> Continuation) { CoroutineHandle = Continuation; } protected: void Resume() { if ensureMsgf(!bResumed, TEXT(""Future already resumed"")) CoroutineHandle.resume(); bResumed = true; } std::coroutine_handle<> CoroutineHandle; bool bResumed = false; } // В общем шаблонном классе мы храним результат template<typename TReturnValue> struct TFuture_Base : FFuture_Base { TOptional<TReturnValue> Result; }; // А в специализаации для void только факт завершения template<> struct TFuture_Base<void> : FFuture_Base { bool bHasResult; }; // Обобщенный шаблонный класс предоставляет возможность пользователю // возобновлять приостановленную сопрограмму вызывая функцию SetResult // А при возобновлении сопрограмма забирает этот результат посредством функции await_resume template<typename TReturnValue> struct TFuture : public TFuture_Base<TReturnValue> { auto await_resume() { return GetResult(); } // Выбираем один из двух SetResult, в зависимости от того какого типа у нас возвращаемое значение template<typename T = TReturnValue> typename TEnableIf<!TIsSame<T, void>::Value, void>::Type SetResult(T&& InResult) { const bool bHasResult = Super::Result.IsSet(); check(!bHasResult); if (bHasResult) return; Super::Result.Emplace(Forward<T>(InResult)); Super::Resume(); } // Если вы используете C++20, то вместо SFINAE было бы неплохо использовать концепты template<typename T = TReturnValue> typename TEnableIf<TIsSame<T, void>::Value, void>::Type SetResult() { const bool bHasResult = Super::bHasResult; check(!bHasResult); if (bHasResult) return; Super::bHasResult = true; Super::Resume(); } protected: TReturnValue GetResult() { if constexpr (TIsSame<TReturnValue, void>::Value) { return; } else { check(Super::Result.IsSet()); return Super::Result.GetValue(); } } }

Ну что ж. Можно вытереть пот со лба. Да, этого всего будет достаточно, чтобы теперь превращать в сопрограммы почти любой асинхронный код! Да бросьте, дальше уже не так страшно.

Использование Task

Задачи можно ожидать и они могут возвращать значения. Здесь я приведу короткие примеры вызова и ожидания задач, а так же использования возвращаемых значений.

// Задача #1 (просто возвращает кортеж) CoroTasks::TTask<TTuple<int32, FString>> Baz() { co_await Delay(4.f); // делаем умный вид, что происходят какие-то длительные асинхронные действия co_return MakeTuple(32, TEXT(""Vasya.Pupkin"")); } // Задача #2 - вызывает и ждёт завершения задачи #1 и принимает в качестве результата кортеж // после чего возвращает целочисленное значение CoroTasks::TTask<int32> Foo() { const auto [Age, Name] = co_await Baz(); co_return Age; } // Задача #3 - вызывает и ждёт завершения задачи #2 и принимает целочисленное значение CoroTasks::TTask<> Bar() { int32 Age = co_await Foo(); }

Таким образом мы можем писать асинхронный код, если где-то требуется продолжительное ожидание. Это удобно. Особенно импонирует использование кортежей, которые отлично передают концепцию множественных возвращаемых значений в асинхронном программировании. Оператор co_await , по сути, передаёт управление в новый таск, который в свою очередь может делать то же самое. При передаче управления выполнение может прерваться вовсе. Взгляните на схему того, как работает передача управления из одной сопрограммы в другую:

Выглядит, как обычные вызовы функций, с той лишь разницей, что на месте блоков-стрелок может происходить реальная приостановка сопрограммы, то есть вернуться в неё можно как сразу, так и спустя продолжительное время, а можно не вернуться вовсе и поток CPU продолжит заниматься своими другими делами. И как раз такие Awaitable как Future явно показывают это. Взгляните на следующую схему:

Future для таймера

В начале статьи я приводил примеры с таймером и поэтому, первым делом, давайте разберёмся с ним. Первое, что мы должны сделать - это создать Future для таймера. Заодно мы создадим задачу и совершим ожидание в этой задаче.

Итак, Future для таймера:

static TSharedRef<CoroTasks::TFuture<void>> Delay(UObject* Context, float Time) { auto Future = MakeShared<CoroTasks::TFuture<void>>(); const FTimerDelegate Delegate = FTimerDelegate::CreateWeakLambda(Context, [Future] { Future->SetResult(); }); FTimerHandle TimerHandle; Context->GetWorld()->GetTimerManager().SetTimer(TimerHandle, Delegate, Time, false); return Future; }

Данный код гласит: мы создаём объект Future, запускаем таймер, который должен будет выставить результат для этой Future и просто-напросто возвращаем эту Future. Дабы избежать копирования, мы используем умную ссылку из фреймворка UnrealEngine.

Для чего параметр Context? Обратите внимание также на параметр Context. Наверное многие сталкивались с тем, что при использовании лямбды в делегатах, которые могут вызваться не просто невесть когда, а уже в момент, когда объект мёртв. Для таких случаев мы хотим сделать предохранитель: чтобы продолжения сопрограммы не происходило, если объект умер, и поэтому мы делаем BindWeakLambda нашему делегату с этим контекстом. Weak - значит лямбда разрушится в момент разрушения объекта-контекста и вызвана впоследствии не будет. В таком случае сопрограмма останется висеть, если её не уничтожить. Поэтому при написании собственных систем на основе сопрограмм имейте это в виду.

co_await TSharedRef? Чтобы код скомпилировался, давайте определим оператор co_await для TSharedPtr<TFuture<T>> template<typename T> CommonCoro::TFuture<T>& operator co_await(TSharedRef<CommonCoro::TFuture<T>> InSharedRef) { return InSharedRef.Get(); } Вообще оператор co_await можно дать почти чему угодно, кроме сырого указателя. Поэтому сделать co_await для UObject* у вас не получится, однако в UnrealEngine существует специальный умный указатель TObjectPtr , то есть свободный оператор можно сделать и с Unreal-объектом. Вообще смысл данного оператора - выдать реальный awaitable объект, который уже может использоваться в co_await -выражении.

А теперь мы попробуем создать первый асинхронный таск с обычным ожиданием в несколько секунд и выводом текста на экран.

void UMyObject::LaunchTask() { auto Task = WaitForSomeTimeTask(); Task.Launch(); // Запускаем наш таск! } CoroTasks::TTask<> WaitForSomeTimeTask() { UE_LOG(LogTemp, Log, TEXT(""Task started"")); co_await Delay(this, 5.f); UE_LOG(LogTemp, Log, TEXT(""Task finished"")); }

Красиво? На мой взгляд это потрясно. Так, а что там насчёт асинхронной загрузки ресурсов?

Асинхронная загрузка ресурсов

На мой взгляд это одна из самых важных задач по асинхронной работе в UnrealEngine. Лично я ненавижу эти делегаты. Хочу я, допустим, дать игроку предмет, а он лежит на диске. Я просто хочу написать короткий код, который достанет ассет предмета с диска и быстренько создаст инстанс. В обычной ситуации мне придётся звать на помощь StreamableManager. Но можно ли как-нибудь обернуть это дело в сопрограммы? Вот как выглядит обычная ситуация, когда мне необходимо получить ассет:

void AsyncLoadAsset_Request(TSoftObjectPtr<UDataAsset> Asset) { // 1. Получаем ссылку на StreamableManager FStreamableManager& Streamable = UAssetManager::GetStreamableManager(); // 2. Создаём делегат const auto OnLoadedDelegate = FStreamableDelegate::CreateUObject(this, &ThisClass::AsyncLoadAsset_Response, Asset); // 3. Используя этот делегат, запрашиваем асинхронную загрузку const TSharedPtr<FStreamableHandle> Handle = Streamable.RequestAsyncLoad({Asset.ToSoftObjectPath()}, OnLoadedDelegate, FStreamableManager::DefaultAsyncLoadPriority); } // 4. Объявляем колбек-функцию, вызываемую делегатом в момент, когда ассет загрузился void AsyncLoadAsset_Response(TSoftObjectPtr<UDataAsset> AssetSoftPtr) { // 5. Получаем указатель на ассет в памяти UDataAsset* Asset = AssetSoftPtr.Get(); // Пользуемся ассетом }

А теперь давайте посмотрим как это будет выглядеть при использовании сопрограмм:

// 1. Объявляем задачу, которую потом запускаем CoroTasks::TTask<> TestCoro() { TSoftObjectPtr<UDataAsset> SoftAssetPtr; // 2. Просто вызываем функцию CoroTasks::AsyncLoadObject на мягкой ссылке ассета UDataAsset* Asset = co_await CoroTasks::AsyncLoadObject(SoftAssetPtr); // Ассет загружен, пользуемся }

Согласитесь, что впечатляет?

Так же привожу в пример код AsyncLoadObject

template<typename T> static TSharedRef<CoroTasks::TFuture<T*>> AsyncLoadObject(const TSoftObjectPtr<T>& SoftObjectPtr, UObject* OptionalContext = nullptr) { auto Future = MakeShared<CoroTasks::TFuture<T*>>(); auto AsyncLoad_Response = [SoftObjectPtr, Future = CopyTemp(Future)] { if (!SoftObjectPtr.IsNull()) check(SoftObjectPtr.Get()->template IsA<T>()); Future->SetResult((T*)(SoftObjectPtr.Get())); }; AsyncLoad_Request({SoftObjectPtr.ToSoftObjectPath()}, MoveTempIfPossible(AsyncLoad_Response), OptionalContext); return Future; } template<typename LambdaType> static void AsyncLoad_Request(const TArray<FSoftObjectPath>& ObjectPaths, LambdaType&& Lambda, UObject* Context) { FStreamableManager& Streamable = UAssetManager::GetStreamableManager(); auto Delegate = FStreamableDelegate::CreateWeakLambda(Context, Lambda); const TSharedPtr<FStreamableHandle> Handle = Streamable.RequestAsyncLoad(ObjectPaths, Delegate, FStreamableManager::DefaultAsyncLoadPriority); }

Данный код взят с моего гитхаба. Ниже будет ссылка на код, где вы можете всё внимательно посмотреть целиком. Как и в случае с таймером, мы также создаём Future и по делегату выставляем результат.

Вызов сопрограмм из Blueprint

А как же блупринты? И блупринты тоже можно включить в работу сопрограмм. По крайней мере мы можем вызывать сопрограммы из блупринтов, чтобы не плодить промежуточные функции. Да и ожидание результата мы тоже можем провернуть в блупринтах, но это не в этой статье.

Данный пример даёт возможность вызывать void-таски из блупринтов:

USTRUCT(BlueprintType) struct FCoroTask #if CPP : public CoroTasks::TTask<void> #endif { GENERATED_BODY() public: using promise_type = CoroTasks::TPromise<void, FCoroTask>; };

""Что за черная магия!?"" - скажете вы. И будете правы. На самом деле это обычный наследник от задачи, которую я описывал выше. Просто, так как это Unreal-тип (USTRUCT), мы не имеем права наследоваться от не-Unreal-структур. Поэтому мы обманываем UnrealHeaderTool чтобы он не паясничал заметил подвоха с помощью директивы #if CPP , которую UHT понимает как ""здесь не анализируй код"".

Теперь мы можем создавать сопрограммы и вызываемые из Blueprint:

UFUNCTION(BlueprintCallable) FCoroTask MyBlueprintCoroTask(TSoftObjectPtr<UItem> ItemAsset) { UDataAsset* Asset = co_await CoroTasks::AsyncLoadObject(SoftAssetPtr); ... }

Однако пытливые читатели тут могут подметить: Оно же не будет выполнено, ведь выполнение данной функции будет приостановлено ещё на момент входа! Помните про std::suspend_always ?

Да, по этой причине мы должны возобновить работу этой функции вручную, написав статическую функцию для FCoroTask :

UFUNCTION(BlueprintCallable) static void LaunchTask(UPARAM(Ref) FCoroTask& Task) { Task.Launch(); }

Можно ещё написать K2Node для таких случаев, чтобы Launch происходил автоматически, под капотом, а сами функции делать BlueprintInternalUseOnly .

Также не забываем, что мы можем модифицировать код так, чтобы конкретно FCoroTask мог не совершать остановку, как исключительная ситуация, используя std::suspend_never .

Кстати, об исключениях.

Исключения

В UnrealEngine не принято пользоваться исключениями. Но ведь это тоже прекрасный инструмент! И с сопрограммами этот инструмент играет особыми красками. А ещё более яркими красками могут заиграть автоматизированные тесты (Unreal Automation Tests) с сопрограммами и исключениями.

Зачем исключения?! У исключений есть серьёзный недостаток. Разворачивание стека - жуть какая тяжелая операция и по этой причине есть мнение, что в разработке игр пользоваться ими плохо. Но исключения можно использовать не обязательно для самого билда игры. Такие вещи как AutomationTests можно запросто использовать и в отдельном модуле. И в таком случае исключениями можно прерывать тесты с разного рода ошибками, которые будут копиться в логах по мере их бросков.

Для начала необходимо понять, в каких же случаях мы можем кидать исключения? И я вижу два таких случая:

Ручной бросок throw в любой момент внутри сопрограммы-задачи. Установка исключения во Future: какое-то действие завершилось, но завершилось оно с ошибкой и мы хотим уведомить об этой ошибке сопрограмму.

Примечательная особенность сопрограммы в том, что она сама ловит исключения, но при этом программист всё равно будет уведомлён о том, что исключение произошло. И происходит это в функции Promise: unhandled_exception . А если мы хотим сами ловить исключения в сопрограмме? В таком случае всё просто, мы просто снова бросаем его. И делается это следующим образом:

struct TPromise : TPromise_Base<ReturnType, TaskType> { void unhandled_exception() { std::rethrow_exception(std::current_exception()); } ... };

Кстати, как же выглядит сопрограмма со стороны компилятора? Вместе с исключениями, у нас должно сформироваться примерное видение во что преобразовывается сопрограмма во время компиляции. И выглядит это так: // Создаётся Promise при входе в сопрограмму TTask<T>::promise_type promise; // Здесь создаётся Task с помощью from_promise TTask<T> return_object = promise.get_return_object(); co_await promise.initial_suspend(); try { 'function body' promise.return_void() or promise.return_value() } catch (...) { promise.unhandled_exception(); } co_await promise.final_suspend(); Как мы видим, unhandled_exception вызывается компилятором при любом исключении. Данный код не является точным примером, во что преобразовывается вызов сопрограммы, однако даёт понимание, что примерно происходит.

В случае же Future, мы хотим какой-то дополнительный метод, наподобие SetResult , но устанавливающий исключение. А ещё исключение надо как-то хранить, не зная явно его тип. К счастью есть такой тип данных: std::exception_ptr , им мы и воспользуемся.

struct FFuture_Base { std::exception_ptr Exception; template<typename TException> void SetException(TException&& Exception) { Exception = std::make_exception_ptr(MoveTemp(Exception)); } ... }

Помните метод await_resume у Future, который возвращает её результат? Теперь мы можем в этой функции и вызвать исключение. Суть в том, что await_resume вызываемся в уже в самой сопрограмме, которая вознамерилась продолжить своё выполнение. Тут-то мы, не ожидающей подвоха сопрограмме, подбрасываем заготовленное ранее пакость исключение:

auto await_resume() { if (Excepton != nullptr) std::rethrow_exception(Exception); return GetResult(); }

Ну и конечно же пример, как бы это потенциально могло бы выглядеть при написании авто-тестов. В примере можно увидеть некий класс FAsyncAutomationTest, будем считать, что он наследник от FAutomationTestBase , но с вот таким асинхронным методом, который будет запускаться вместо обычного синхронного завершения результата.

bool FAsyncAutomationTest::RunTest(const FString& Parameters) { auto Task = RunAutoTest(Parameters); Task.Launch(); return true; } CoroTasks::TTask<> FAsyncAutomationTest::RunAutoTest(const FString Parameters) { SetSuccessState(true); bSuppressLogs = true; try { co_await AsyncRunAutoTest(Parameters); } catch (const FAutotestFailure& Exc) { const FString ErrorMessage = Exc.GetMessage(); UE_LOG(LogTemp, Error, TEXT(""Test failed with reason: %s""), *ErrorMessage); AddError(ErrorMessage); SetSuccessState(false); } bSuppressLogs = false; }

Примечание: Будьте аккуратны с передачей строк по ссылке ( & ) в сопрограммы. Такие строки будут уничтожены при выходе из Scope, вызывающего сопрограмму.

Теперь мы можем писать асинхронные авто-тесты и в разных исключительных ситуациях видеть какие ошибки у нас в OutputLog при окончании теста.

Потенциальный пример использования:

IMPLEMENT_AUTOMATION_TEST_ASYNC(FMyAsyncTest, ""AsyncTest.MyTest"", EAutomationTestFlags::EditorContext | EAutomationTestFlags::ProductFilter, 2, ""MyAsyncTest"") CoroTasks::TTask<void> FMyAsyncTest::AsyncRunNetworkedTest(const FString Parameters) { if (UAsyncTests::IsServer()) { UWorld* World = UAsyncTests::GetServerWorld(); ATestActor* Actor = World->SpawnActor<ATestActor>() } co_await UAsyncTests::JoinPlayers(); if (UAsyncTests::IsClient(0)) { UWorld* World = UAsyncTests::GetClientWorld(0); TArray<AActor*> Actors; UGameplayStatics::GetAllActorsOfClass(World, ATestActor::StaticClass(), Actors); if (Actors.Num() == 0) throw FNetError(""Can't find actor that spawned on server. It seems not replicated""); } }

Test failed due to NetError: Can't find actor that spawned on server. It seems not replicated

Выводы и заключение

Лично я считаю, что сопрограммы имеют огромный потенциал в разработке на UnrealEngine. Примеры, которые я привёл, явно это показывают.

Хочется отметить, что вместе со всем этим делом не хватает RPC в системе синхронизации клиент-сервера UnrealEngine. Поэтому хотелось бы, чтобы в будущем сопрограммы понимал и UnrealHeaderTool. Тогда мы могли бы совершать удалённый вызов UFUNCTION и ждать результата. Но пока, подобное можно реализовывать, разрабатывая свои собственные веб-сервисы, с которыми может взаимодействовать игра.

Кстати разработчики UnrealEngine сами развивают тему с сопрограммами, но пока на уровне Experimental. Если интересно, то можно заглянуть сюда Core\Public\Experimental\Coroutine . Их реализация задач (Task) несколько отличается от того, что я привёл здесь, поэтому не получится ими воспользоваться в тех задачах, которые привёл я.

Хочу также упомянуть, что LiveCoding не работает с сопрограммами на момент UnrealEngine 5.1, но в 5.2 это должны исправить: https://github.com/MolecularMatters/lpp_public/issues/3#issuecomment-1422557992

Репозиторий с кодом, который используется в этой статье, где можно пощупать сопрограммы в UnrealEngine: https://github.com/broly/UnrealCoroTasks

Также большая активность по сопрограммам у автора проекта UE5Coro. Думаю, что заинтересованным, точно стоит туда заглянуть."'https://habr.com/share/publication/720868/e8c6a31544f16c8cafdfb5bd1c40b8fb/'"['https://habrastorage.org/r/w32/getpro/habr/avatars/9de/a00/9e0/9dea009e0319ad2a8ec279885f00a711.jpg', 'https://habrastorage.org/r/w780q1/getpro/habr/upload_files/fbf/9e0/332/fbf9e0332c546e5de84120aca64d7c2a.jpg', 'https://habrastorage.org/getpro/habr/avatars/9de/a00/9e0/9dea009e0319ad2a8ec279885f00a711.jpg', 'https://habr.com/share/publication/720868/e8c6a31544f16c8cafdfb5bd1c40b8fb/', 'https://habrastorage.org/r/w780q1/getpro/habr/upload_files/106/627/5fb/1066275fbc777daa3ec65fc83fd28292.jpg', 'https://mc.yandex.ru/watch/24049213']"
1'720858'Пошатывание устоев или из FAANG в HFT-стартап'Я - разработчик серверных компонент со стажем в 10+ лет (C++, python). Не трейдер и не квант. Эта статья - результат моих годичных наблюденией, когда после 8 лет в больших IT-корпорациях, я внезапно...'https://habr.com/ru/post/720858/'"Я - разработчик серверных компонент со стажем в 10+ лет (C++, python). Не трейдер и не квант. Эта статья - результат моих годичных наблюденией, когда после 8 лет в больших IT-корпорациях, я внезапно нырнул в HFT-стартап с коллективом в сотню человек. Что в разнице подходов к разработке удивило меня сильнее всего?

Для начала, пара слов о рассматриваемых сторонах:

Про FAANG , как работодателя, все миллион раз изложено и известно. В представлении многих разработчиков это последняя инстанция карьерного роста, бесплатная еда, огромные мониторы, гениальные коллеги. Я несколько скептичен по отношению к этим компаниям и успел уже немного поныть тут . Дело в том, что там много бюрократии, долгие циклы и часто встречающееся отсутствие интереса к результату. Но зато есть хорошая компенсация и стабильность , как минимум, до недавнего времени.

HFT (high frequency trading) - ниша технологических компаний, которые занимаются автоматической торговлей на биржах, и, исходя из определения, делают это с высокой частотой. Термин весьма неспецифичен, и задачи, подходы, статусы на рынках у таких компаний довольно разные. Однако, технические решения похожи - критическим фактором для успешности в области является скорость реакции на рыночные изменения. Скорость позволяет обходить конкурентов и хорошо конвертируется в деньги. В этой сфере есть несколько больших игроков, но и множество маленьких компаний вполне способы зарабатывать себе на безбедное существование (если верить их hr).

В целом, многие из моих наблюдений могут быть объяснены значимостью скорости ваших программ и частотой релизных циклов. Вы можете возразить, что скорость важна и в корпорациях. Не зря же они все эти деревья просят развернуть на собеседованиях да асимптотики спрашивают. А как же экономия на тысячах серверов и мегатонны выбросов CO2? Но я не соглашусь, так как везде, где я работал, более важными свойствами систем были надежность и универсальность, а потом уже оптимизация, если вам совсем нечего делать. Выделить 19 ядер на простой веб сервис с БД при нагрузке в 1 rps? Почему бы и нет, зато все надежно, реплицировано и защищено от отряда экскаваторщиков в поиске кабелей датацентра.

Итак, перечисляю основные тезисы и стараюсь не нарушить никакие NDA:

Лучшие решения - простые

Вроде бы, ничего нового и особо умного. ""Все гениальное - просто"", принцип Парето, Бритва Оккама и т.д. отлично согласуются с этим наблюдением. Но есть нюанс: многие вещи вокруг нас только внешне очень просты.

Например, есть у вас дата+время в текстовом потоке данных, и их надо распарсить. Большинство разработчиков обратятся к документации их любимых языков в поисках нужного модуля, подключат эту штуку и будут молодцами в 99% случаев. Один вызов для конвертации текста в нужную структуру и все готово, что может быть проще? Но если посмотреть, что происходит в этом модуле, то мы обнаружим работу с текущей локалью ОС, какие-то непонятные виртуальные функции для работы с календарем, всевозможными форматами дат и еще невесть что. А у вас всегда один и тот же формат, данные всегда в одном порядке, и потом еще выяснится, что вам из даты нужны только месяц и день. Код, который делает ровно то, что нам от него надо, будет работать очевидно быстрее.

Конечно, на одном таком улучшении далеко не уедешь, но принцип вырисовывается - минималистичные, нередко и самописные решения предоставляют лучшую эффективность. С таким подходом сложнее разбираться и надо активнее поддерживать, что часто избыточно для крупных компаний, но, с другой стороны, в очень высококонкурентной среде это оправдано и превращается в деньги. Поэтому в HFT много горячих путей, а простое надо еще уметь сделать качественно.

Больше велосипедов богу велосипедов

Использование готовых решений - краеугольный камень эффективной разработки, но предыдущий пункт нас подводит к тому, что многие вещи придется писать самостоятельно. И не только потому, что у них скорость низкая, но и потому, что вы не доверяете решениям сторонних разработчиков. А цена программной ошибки (или взлома) может быть слишком велика. Например, исчезновение вашей компании .

Хотя отмечу, что велосипедные решения, которые неуместны в приличных местах, в очень больших корпорациях так же естественны. В многих компаниях FAANG вы встретите собственные решения для стандартных задач. Там это чаще всего мотивировано высокими нагрузками, желанием независимости от сторонней поддержки, а также наличием незанятых разработчиков.

Отсутствие авторитета стандартов и подходов

Раньше я довольно наивно полагал, что умение писать высоконагруженные системы на C++ так или иначе пересекается с владением многопоточностью. Активно применял ее в своих проектах, изучал свойства модели памяти, семантики атомарных типов и т.д. А потом, в окружении с приличной нагрузкой и огромной важностью задержки, я встретил постулат ""никакой многопоточности"". Так как это сложно, делает код неочевидным и обладает известными накладными расходами. А накладные расходы, как мы уже заметили, это плохо. И тут я напомню, что некоторая синхронизация потоков также проросла в такие безобидные инструменты C++ как static и в некоторые умные указатели. И вот вы в 2023 перестаете смущаться использования сырых указателей, которые были избегаемы вами много лет. Ведь вы знаете, что делаете. Что может пойти не так?

Сталкиваясь с подобными ситуациями, понимаешь, что многие наставления о хорошем написании кода или проектировании перестают быть авторитетными в экстраординарных ситуациях. Собственно, они для этого и не предназначались никогда.

Также отмечу, что это касается не только кода - популярные инфраструктурные решения, конечно же, также подвергаются пересмотру, будь это системы виртуализации/контейнеризации, транспортные протоколы и пр. Инфраструктура для высокочастотной торговли важна не менее кода.

Доступность не так уж и нужна

Работая в огромных компаниях, в один прекрасный день вы можете обнаружить себя на серии часовых встреч, где обсуждаются сценарии, с которыми может столкнуться ваш сервис. И эти сценарии подходят для какой-нибудь антиутопии. Потому что все они очень печальны, но совершенно невозможны.

Для таких компаний репутационные потери от даунтаймов - это очень плохо, инвесторы такое не любят. Вот они и хотят, чтобы сервисы их компании были в работе все 100% времени. Но на разработку и поддержку подобных проектов, защиту от невозможных ситуаций и иные способы страховки разработчики тратят действительно много времени, которое они могли бы потратить на запуск чего-то нового. Чего-то, что принесет больше денег, чем защита от даунтайма на пару часов раз в несколько месяцев. Хотя, отсутствие этой защиты и сделает вашу работу несколько более нервной. Особенно во время дежурств.

В общем, идея страхования только там, где ""тонко"", и избыточности стопроцентной доступности может вас удивить после мании корпоративной стабильности. Кстати, это же касается и высоких процентов покрытия тестами.

Найм умер

Точнее, он сильно сломан в корпорациях. Алгоритмические секции, которые проверяют усердность в решении топ100 литкода, поведенческие и “культурные” секции, проверяющие вашу способность приукрашивать, это все очень интересно и, наверное, может дать объективность на большом потоке людей. Однако, этот подход очевидно плохо тестирует знания и умения нужные непосредственно вашей команде. А в местах с буткампом, попадание нового сотрудника в случайную (относительно его навыков) команду только усугубляет проблему. На выходе получается, что уровень коллег, после подобной фильтрации, не такой уж и высокий, как общепринято считать.

В компаниях же, где найм не поставлен на конвейер на полгода вперед, но которые тоже способны забирать лучших с рынка, ваша будущая команда будет оценивать вас по действительно важным навыкам, а значит, шанс случайных людей вокруг будет ниже.

Насколько для вас это проблема или преимущество - вопрос открытый.

Интересные ежедневные задачи

Далеко не всем нравится работать “в финансах"", и некоторые из аргументов против вполне логичны. Скромное влияние на общество, например. Мегакорпорации же позиционируют себя как важные явления современности, которые тут не просто рекламой деньги зарабатывают, а сеют разумное, доброе, вечное.

Правда, находясь там и занимаясь оптимизацией некоторой метрики, рост которой никто никогда нигде не заметит, вы также можете справедливо спрашивать себя: не ерунду ли я делаю? На некоторых проектах вы вообще будете игнорировать код месяцами, писать документы и посещать нескончаемые митинги. И только на словах ваша работа будет казаться окружающим чем-то классным.

Большинству HFT-компаний не особо выгодно разрастаться, а работая в компании с штатом в сто раз меньше, вы будут винтиком в сто раз больше. И даже если влияние на окружающий мир будет не таким большим, как вам хотелось бы, вероятность заниматься интересными инженерными задачами может быть существенно выше.

Что в итоге

Все это можно просуммировать как отрицание обобщений и уменьшение расточительности. Это кажется логичным, так как большие компании хотят универсальности для уменьшения порога вхождения в свои проекты, а также готовы потянуть некоторые перерасходы. В HFT же расточительность напрямую бьет по вашей годовой премии, а небольшие команды опытных специалистов могут себе позволить высокий порог вхождения. Таким компаниям нужно, чтобы ваш код помогал зарабатывать деньги, а не состоял из классных абстракций. И хотя это применимо ко всей коммерческой разработке, там это чувствуется острее, а многое из того, что везде считается хорошим тоном, может быть подвергнуто сомнению в пользу мгновенной выгоде.

С другой стороны, описанные практики вполне могут сделать вас весьма “деформированным” и не очень пригодным для работы в иных местах. Я бы рекомендовал движение от общего к частному. Но и грезить только огромными корпорациями, как местом, где можно сидеть до пенсии, возможно, не стоит."'https://habrastorage.org/getpro/habr/upload_files/9a5/0dc/132/9a50dc1323756441062606e7ad6667cd.jpeg'"['https://habrastorage.org/getpro/habr/avatars/653/caa/958/653caa958da4168b791af12709790e47.jpg', 'https://habrastorage.org/r/w780q1/getpro/habr/upload_files/a59/331/7d7/a593317d7e767c4401eb12b4d548a234.jpeg', 'https://mc.yandex.ru/watch/24049213', 'https://habrastorage.org/r/w32/getpro/habr/avatars/653/caa/958/653caa958da4168b791af12709790e47.jpg', 'https://habrastorage.org/getpro/habr/upload_files/9a5/0dc/132/9a50dc1323756441062606e7ad6667cd.jpeg']"
2'720856'Мой издательский пост'Давным-давно, ещё, когда я жил в Минске, одним из моих старших друзей был удивительный инженер Павел Горбунов, интеллектуал, романтик и автор множества афористичных мыслей, из которых мне наиболее...'https://habr.com/ru/post/720856/'"Давным-давно, ещё, когда я жил в Минске, одним из моих старших друзей был удивительный инженер Павел Горбунов, интеллектуал, романтик и автор множества афористичных мыслей, из которых мне наиболее запомнилась «Кто пребывает в нирване, часто ходит в рванине». Он работал в машиностроительном КБ и также говорил, что «у меня большинство друзей – программисты, а я люблю, что плоды моей работы можно пощупать руками». Сейчас, приближаясь к тому возрасту Горбунова, я также хочу рассказать о той части моей работы, которую можно потрогать руками – то есть, о книгах.

В редакции Хабра я работаю с конца 2020 года, а с февраля 2021 вернулся к издательской деятельности и с большим удовольствием тружусь в издательстве «БХВ» из Санкт-Петербурга. Такое название сохранилось с середины 90-х, когда компания была совместным российско-немецким предприятием и называлась на латинице «BHV», что по-немецки расшифровывается как «BuchHandel und Verlag» - «Книготорговля и издательство». Естественно, в начале 2021 года я воспринял новообретённую аудиторию Хабра как потенциальный пул авторов. Внимательно смотрел профили моих читателей, ко многим обращался в личку, если видел в их (хабро)блогах или на гитхабе потенциальную основу для технической книги. Теперь, поскольку этот поиск принёс ощутимые плоды, я хотел бы рассказать о наиболее интересных переводных и авторских книгах, которые мне удалось выпустить за прошлый год и начало текущего года – а также поблагодарить тех, кто решился со мной работать и, надеюсь, не разочаровался в этом.

Алгоритмический тренинг. Решения практических задач на Python и С++ (Максим Иванов)

Ссылка на книгу

Аннотация

Алгоритмы и структуры данных — основа профессиональной подготовки программиста. В библиотеке профессионала найдутся многотомные неустаревающие труды по этой теме. Но, чтобы выйти за рамки академической Computer Science и перейти к реальной практике, алгоритмы нужно быстро подбирать и применять. Автор этой книги работал над ней более 10 лет, опираясь на свой богатый опыт олимпиадного и спортивного программирования.

В книге собраны варианты реализации и применения важнейших алгоритмов в условиях быстрого принятия решений — что незаменимо на собеседованиях и конференциях. Также книга может быть полезна для подготовки к экзаменам, олимпиадам и соревнованиям по программированию. Но в большей степени она позиционируется как настольная книга для начинающих программистов, желающих быстро и интересно приобрести качественную алгоритмическую подготовку — и претендовать на достойное предложение о работе. Реализации всех алгоритмов даны на двух языках — Python и С++.

О книге

Максим Иванов @emaxx постучал мне в личку в апреле 2021 года, прочитав переводной пост «Виртуальных частиц не существует». Обратился по поводу мелкой ошибки. На тот момент я изыскивал варианты издать книгу, которая давала бы базовую алгоритмическую подготовку, но была максимально высокоуровневой и при этом доступной. В профиле Максима я нашёл именно такую книгу http://e-maxx.ru/upload/e-maxx_algo.pdf по состоянию на 2012 год – и предложил Максиму обновить её, дав реализации распространённых алгоритмов на языках C++ и Python. Максим с готовностью согласился дорабатывать свой старинный труд, был чрезвычайно внимателен к нашим литературно-редакторским и оформительским правкам. Несколько раз проект задерживался, в особенности весной-летом 2022 года, так как книга заметно подорожала вместе с бумагой. Тем не менее, сейчас книга Максима является настоящим бестселлером (входит в топ-20 в актуальном ассортименте издательства), вероятно, будет допечатана до конца года.

По ходу работу рассматривался вариант названия «Алгоритмический воркаут», и я отдельно хотел бы поблагодарить Максима за то, что он согласился на более нейтральный вариант «Алгоритмический тренинг». Дизайн обложки продиктован тем, что дерево является одной из самых распространённых и многогранных структур данных.

Хит на Хабр (Антон Поляков)

Ссылка на книгу

Аннотация

Книга рассматривает малоисследованный аспект технического писательства и продвижения: ведение технического блога. Автор книги Антон Поляков, много лет отдавший сайту «Хабр», на многочисленных примерах пошагово раскрывает секреты мастерства и помогает освоить ведение информативного и рентабельного технического блога во всех деталях. При этом невозможно переоценить влияние сообщества читателей как на восприятие контента, публикуемого в блоге, так и на развитие имиджа автора или компании, которым блог принадлежит. Поэтому за основу для книги было взято сообщество «Хабр» с его обширной аудиторией, исключительным тематическим разнообразием, бескомпромиссными интеллектуальными дискуссиями, а также уникальными системами «кармы» и «рейтинга», практически не оставляющими шанса откровенно бросовым или бездумно проплаченным материалам.

О книге

С Антоном Поляковым @AntonPolyakov мы списались в конце апреля 2021 года. Ранее Антон работал в редакции Хабра, и я случайно вышел на его авторский курс по ведению технического блога на сайте it-content.pro/. Антон со знанием дела подошёл как к рассказу о блоггинге, так и к секретам технического писательства и техноавторства. На тот момент я сам ещё только осваивал работу с Хабром, и книга Антона открыла мне глаза на многие вопросы, в частности, на оптимальную длину публикации, выигрышное время публикации, на отработку комментариев и подбор тем для блога. Книгу высоко оценили действующие сотрудники редакции Хабра, в частности, @Boomburum и @IgnatChuker. Надеюсь, также эта книга пригодилась кому-то из завсегдатаев или новичков Хабра, позволила закрепиться в корпблоге или просто прокачать скиллы лонгридолелания.

Обучение с подкреплением для реальных задач (Фил Уиндер)

Ссылка на книгу

Аннотация

Книга посвящена промышленно-ориентированному применению обучения с подкреплением (Reinforcement Learning, RL). Объяснено, как обучать промышленные и научные системы решению любых пошаговых задач методом проб и ошибок – без подготовки узкоспециализированных учебных множеств данных и без риска переобучить или переусложнить алгоритм. Рассмотрены марковские процессы принятия решений, глубокие Q-сети, градиенты политик и их вычисление, методы устранения энтропии и многое другое. Данная книга – первая на русском языке, где теоретический базис RL и алгоритмы даны в прикладном, отраслевом ключе.

Для аналитиков данных и специалистов по искусственному интеллекту

О книге

Решился выносить на обсуждение эту книгу после долгих размышлений о том, в каких сферах кроме чисто игровых моделей может быть полезно обучение с подкреплением. На тот момент активно общался с уважаемым @BlindZ0ne на тему применения искусственного интеллекта в финансовой и биржевой сфере, и именно его выкладки подвигли меня на проработку этой книги. Я остался доволен практическим уклоном этой книги, получал положительные отзывы о том, как в ней рассмотрены градиенты политик и подбор вознаграждения в сложных быстро меняющихся (финансовых) системах. Тем не менее, до исчерпания первого тиража ещё далеко.

Rust в действии (Тим Макнамара)

Ссылка на книгу

Аннотация

Книга о прикладных аспектах языка программирования Rust, описывающая внутреннее устройство языка и сферы его использования. Rust рассматривается как современное дополнение для С при программировании ядра ОС и при системном программировании, а также как низкоуровневый скоростной язык, обеспечивающий максимальную производительность. Объяснены тонкости работы с процессором, многопоточное программирование, работа с памятью, а также взаимодействие с Linux. Изложенный материал позволяет как писать современные приложения на Rust с нуля, так и внедрять Rust в сложившуюся базу кода.

Книга ориентирована на специалистов по C, Linux, системному программированию и на всех, кто желает освоить Rust и сразу приступить к работе с ним.

О книге

Я несколько лет следил за работой над этой книгой; по разным причинам, в том числе, личным, автор приостанавливал работу над ней. Это была не первая на российском рынке книга по Rust, но книга, пожалуй, наиболее своевременная, которая не только хорошо вписалась в нишу системного программирования и совпала по выходу с включением Rust в ядро Linux, но и стала настоящей находкой для корифеев блокчейна. В данный момент один из наиболее успешных и, надеюсь, долговечных моих проектов. Также рад буду обсудить возможную авторскую книгу о Rust под Linux, заинтересовавшиеся могут писать в личку.

Linux и Go. Эффективное низкоуровневое программирование (Олег Цилюрик)

Ссылка на книгу

Аннотация

Первая русскоязычная книга об интеграции языка Go в архитектуру ядра Linux. Содержит вводный курс по языку Go для системного программирования, описывает применение Go для реализации конкурентности и параллелизма, рассказывает об интероперабельности между имеющимся кодом на C с новым кодом на Go, а также исследует возможности внедрения Go для повышения производительности различных дистрибутивов.

Книга ориентирована на программистов и системных администраторов, работающих с Linux, будет интересна разработчикам ядра Linux и драйверов устройств.

О книге

Именно на фоне поисков потенциальной книги о Rust под Linux мне довелось попасть на сайт Олега Ивановича Цилюрика – было это в конце февраля прошлого года. Олег Иванович @Olej – просто легенда в мире Linux и системного программирования, ранее сотрудничал с санкт-петербургским издательством «Символ-Плюс» и с коммерческими компаниями.

В настоящее время язык Go в ядре Linux образует важные и интересные вкрапления (в особенности, с точки зрения параллелизма), но дать целостную картину по такой непростой теме мог только человек, ориентирующийся в kernel space буквально с закрытыми глазами. Динамика продаж книги в последние пару месяцев по-хорошему обескураживает, обсуждаем с Олегом Ивановичем перспективы второго издания.

В марте готовится к выходу вторая книга Олега Ивановича, написанная им для нас на основе более чем двадцатилетних наработок.

Расширения ядра Linux: драйверы и модули

Ссылка на книгу

Аннотация

В книге подробно рассмотрено программирование драйверов ядра Linux, исследованы возможности расширяемости ядра при помощи модулей. Основная версия ядра – 5.15. Код примеров отработан и проверен на десятках различных инсталляций Linux, установленных из различных дистрибутивов и разных семейств дистрибутивов: Fedora, CentOS, Debian, Ubuntu, Mint. Уделено внимание архитектурам x_64, x_86, ARM, а также одноплатному компьютеру Raspberry Pi и драйверам устройств, подключаемых по USB. Затронут стандарт POSIX, разобраны API ядра, работа с Raspberry Pi, системные вызовы и подключение разнообразных периферийных устройств.

Для программистов и системных администраторов

О книге

Читателям ещё предстоит оценить эту книгу, однако я не сомневаюсь в её успехе. В этом фолианте на 688 страниц Олег Иванович во всех тонкостях рассмотрел программирование и применение драйверов ядра — создав аналог легендарной книги «Linux Device Drivers», третье издание которой на русском языке так и не вышло, а четвёртое не состоялось даже по-английски. Следите за ссылкой, скоро она оживёт. Олег Иванович, ещё раз спасибо вам за ваш титанический труд и энциклопедические знания в предметной области.

Глубокое обучение и анализ данных. Практическое руководство (Дмитрий Малов)

Ссылка на книгу

Аннотация

Книга о принципах глубокого обучения, описывающая построение и развитие нейронных сетей с нуля. На материале обширных практических наработок в сфере распознавания образов и обработки естественного языка продемонстрированы возможности популярной библиотеки Pytorch, а также Keras и Tensorflow. Особое внимание уделено разбору базовых алгоритмов, реализованных на языке Python, которые помогут самостоятельно освоить работу с нейронными сетями, написав собственное приложение для глубокого обучения на основе данных из браузера.

Для Python-разработчиков и специалистов Data Science

О книге

Несколько лет назад, после не самого удачного перевода «Dragon Book», на российском рынке доминировали две книги по глубокому обучению – исходно русскоязычная под авторством Сергея Николенко @snikolenko и переводная книга от Франсуа Шолле. Затем рынок начал фрагментироваться, а нейронные сети стали развиваться так быстро, что сориентироваться в архитектурах и библиотеках стало невероятно сложно. Книга Дмитрия Малова из Санкт-Петербурга также готовилась почти полтора года, поскольку автор забирал черновики и переписывал, желая угнаться за технологией. И вот эта книга готова – выход её ожидается в марте. Пожалуй, это самое компактное и простое руководство для погружения в Keras и Tensorflow, а также в алгоритмы для обработки естественного языка. В книгу вошли многолетние наработки автора, в частности, по компьютерному зрению и DL в браузере. Кроме того, эта книга одной из первых на русском языке рассматривает сверхпопулярную библиотеку PyTorch – и кажется наиболее лёгким, разносторонним и удобоваримым введением в глубокое обучение для начинающих.

Информационная безопасность для пользователя. Правила самозащиты в Интернете (Михаил Райтман)

Ссылка на книгу

Аннотация

Книга о безопасной работе в Интернете и защите персональных данных, в том числе с соблюдением мер анонимизации и приватности. Рассматриваются вопросы выбора надежных паролей, использования прокси-серверов, анонимных сетей и VPN, технологии шифрования и защищенного общения. Особое внимание уделено анонимной операционной системе Tails, рекомендуемой Эдвардом Сноуденом. Приведены способы конспиративного общения по защищенным каналам связи и подключения к анонимным сетям, таким как I2P RetroShare и др. Даются практические рекомендации по безопасной работе с торрентами, мессенджерами, файловыми архивами. Книга поможет разобраться в устройстве Даркнета и варезной Сцены. Отдельная глава посвящена луковой архитектуре и браузеру Tor. Особое внимание уделено кастомизации устанавливаемых программ.

Для специалистов по безопасности, системных администраторов, уверенных пользователей Linux

О книге

Нас с Михаилом Райтманом объединяет более восьми лет плодотворнейшего переводческого и редакторского сотрудничества, однако сильнейшей стороной этого автора является экспертиза в обеспечении приватности данных, умение проникнуть в Интернете куда угодно и выудить из Сети что угодно. Сначала эта книга планировалась как переиздание его же работы «Искусство легального, анонимного и безопасного доступа к ресурсам Интернета», но позже оформилась в самостоятельное произведение, отражающее реалии нынешней VPN-эпохи. Книга настолько же самобытная и самодостаточная, насколько необходимая сейчас и в ближайшем будущем.

Java. Состояние языка и его перспективы (Федор Урванов)

Ссылка на книгу

Аннотация

Книга о современном состоянии языка Java, векторе его развития, а также о грамотном программировании в духе паттернов GoF. Книга дает базовое представление о фреймворке Spring, контейнерах Docker, принципах ООП, затрагивая, в частности, переход к облачным решениям, обращение с IDE. Также освещены темы из enterprise-разработки: файловый ввод/вывод NIO2, многопоточность, локализация, интеграция и оптимизация производительности. В книге отражено состояние языка по состоянию на версию Java 17 с разбором некоторых аспектов Java 18.

Будет интересна специалистам, возвращающимся к работе с Java после перерыва, бэкенд-разработчикам, читателям, готовящимся к сертификационным экзаменам.

О книге

Федор Урванов @urvanov собрал на авторском сайте https://urvanov.ru наработки по нескольким востребованным технологиям – не только по Java, но и, например, по TypeScript. Его электронный учебник по Java был посвящён версии Java 8, но Федор любезно согласился быстро и глубоко обновить эту книгу до Java 17 с захватом Java 18 и смежных технологий. Издавать книгу с указанием версии – всегда большой риск, связанный с устареванием материала, однако Федор блестяще справился с работой, что прямо следует из отгрузок. Полагаю, господин Урванов продолжит работу с нами и порадует сообщество новинкой (новинками)? – пока мы предметно обсуждали книгу о Spring и Spring Boot.

Заключение

Итак, для первого впечатления вполне достаточно. У нас на сайте ещё много интересных книг, в особенности рекомендую обратить внимание на бестселлеры (раз, два) Ольги Назиной, посвящённые тестированию. В обозримом будущем ждите от меня книг по следующим темам (всё нижеперечисленное – на этапах от «в редактуре» до «обложка готова»):

1) MySQL

2) DDD

3) Kubernetes

4) Чистый код

5) DOP (дата-ориентированное программирование)

6) Приватность данных

7) Глубокое обучение

8) Параллельное программирование

9) Алгоритмы на C++

10) Infrastructure as Code

11) Kaggle

….

Сложились бы эти проекты без Хабра? Какая-то доля из них – несомненно, но именно Хабр и в первую очередь Хабр в настоящее время позволяет мне ориентироваться в технологическом ландшафте и находить не только авторов, но и талантливых редакторов (спасибо, уважаемые @Evgeny_Chernyy, @TraurigerNarr, Сергей Баранов). Отдельное спасибо за помощь в поиске вдохновения и векторов развития для новых проектов уважаемым @visirok и @Loriowar. Надеюсь, этот длинный пост не утонет в критике, поможет мне оживить контакты со многими другими авторами, которые планировали писать для нас книги, но пока не довели дело до результата, а также приведёт мне новых талантливых писателей-технарей. Спасибо, что дочитали."'https://habrastorage.org/getpro/habr/upload_files/1ad/aa8/f99/1adaa8f991f45c0687a8af9ae31c3d69.jpg'"['https://habrastorage.org/r/w780q1/getpro/habr/upload_files/d2d/b00/958/d2db009581fc3b6d96034652228b1ac9.jpg', 'https://habrastorage.org/r/w32/getpro/habr/avatars/34a/b85/90f/34ab8590fc34309be944c1d9daf70d94.jpg', 'https://habrastorage.org/r/w780q1/getpro/habr/upload_files/51a/314/32c/51a31432ce9e1e504bbaf2829d5a721b.jpg', 'https://habrastorage.org/getpro/habr/avatars/34a/b85/90f/34ab8590fc34309be944c1d9daf70d94.jpg', 'https://habrastorage.org/r/w1560/getpro/habr/upload_files/0ec/c6c/515/0ecc6c515f7c0e70b29c0e3bab20b5e6.png', 'https://habrastorage.org/getpro/habr/upload_files/1ad/aa8/f99/1adaa8f991f45c0687a8af9ae31c3d69.jpg', 'https://habrastorage.org/r/w1560/getpro/habr/upload_files/091/784/0c8/0917840c871b6ea32940edff9392a8b0.png', 'https://habrastorage.org/r/w780q1/getpro/habr/upload_files/f81/fd7/80e/f81fd780e9af13b5f6a9ea9ca57a388f.jpg', 'https://mc.yandex.ru/watch/24049213', 'https://habrastorage.org/r/w1560/getpro/habr/upload_files/9e7/050/7f6/9e70507f6bf7a8aac1e8b030d20c7e19.png', 'https://habrastorage.org/r/w780q1/getpro/habr/upload_files/9f1/9f1/b3b/9f19f1b3b9399e362daa48ff49508514.jpg', 'https://habrastorage.org/r/w780q1/getpro/habr/upload_files/607/d5d/270/607d5d270743b6003bb2ce0e81447326.jpg', 'https://habrastorage.org/r/w780q1/getpro/habr/upload_files/d07/322/dfe/d07322dfee3b6321279f588049775252.jpg']"
3'720864'Муки выбора системного аналитика на проект в большую организацию'Многие вещи, написанные ниже покажутся тривиальными, но я все же не буду их опускать, чтобы картинка сложилась полная. Бюрократия, а именно, написание должностных инструкций, составление договора,...'https://habr.com/ru/post/720864/'"Многие вещи, написанные ниже покажутся тривиальными, но я все же не буду их опускать, чтобы картинка сложилась полная.

Бюрократия, а именно, написание должностных инструкций, составление договора, согласование штатных единиц, выделение бюджета и т.п. не входят в рамки данной статьи. Вопрос выбора формата аутсорс/инхауз также не рассматриваются в статье.

Почему в принципе уделяю время этой теме? Найм квалифицированного специалиста является вещью дорогостоящей. Цена складывается так: внешние расходы на рекрутинг (hr) + внутренние расходы на рекрутинг (команда) + онбординг и адаптация + з.п. и различные бюджетные взносы. И если сотрудник с з.п. на руки, например, в 100 тыс.руб. увольняется спустя неделю после найма, ничего еще по сути не успел сделать, то затраты организации на поиск, найм и адаптацию этого работника могут составлять, например, 150-200 тыс, из которых сотрудник на руки получит только 25 тыс. Найм 3х-4х ""недельных"" сотрудников может обернуться в очень даже круглую сумму. Вот такой айсберг.

Задача найма СА на проект довольно узкая, ее границы:

выбрать системного аналитика (далее СА). Т.е. выбирается не бизнес-аналитик, не кросс-функциональный аналитик, а именно системный. выбрать СА на определенный проект. Означает, что СА должен обладать специфичными знаниями и навыками, свойственными для данного проекта. выбрать в большую организацию. Это важно, т.к. в больших организациях есть бюрократия.

Сразу оговорюсь, что есть разные аналитики: бизнес-аналитики, продуктовые аналитики, системные аналитики, аналитики данных, и т.п. Тут речь про СА. Если описать просто и описать одним предложением, то СА - это переводчик между заказчиком и разработчиком. Для СА заказчиком может быть как непосредственно бизнес, так и бизнес-аналитик. Исходя из этого определения можно сказать, что СА как минимум умеет изъясняться на двух языках: язык моделирования бизнес-процессов и технический язык.

Итак, я ниже опишу как я подхожу к найму сотрудника по шагам.

Шаг 1. Формирование запроса

Т.к. организация большая, то поиск осуществляется через HR - классическая воронка. Для того, чтобы воронка была эффективной необходимо хорошо сформировать запрос. Это нужно для того, чтобы как минимум:

отсеить явно неподходящих кандидатов, не отфильтровать подходящих кандидатов, заинтересовать нужных кандидатов,

Запрос должен содержать:

описание проекта, функциональные обязанности. Желательно не общими фразами, а вполне конкретными. Если аналитик будет проектировать аналитические кубы, а затем их проверять, то я так и напишу: проектирование OLAP, разработка правил оценки качества данных, участие в тестировании, уровень сотрудника. Для одной позиции потребуется джун, а для другой синьор - нужно понимать кого искать, скиллы, ожидаемых от работника (как хард, так и софт). Можно разделить на желаемые и обязательные, Опыт работы по направлению, прочие важные аспекты, которые могут привлечь или оттолкнуть кандидата. Описание формата работы, мотивации и прочее.

Само собой, чтобы подготовить запрос на СА, который будет вести проект нужно самому предварительно вникнуть в проект.

Итак запрос сформирован и отправлен HR.

Шаг 2. Организовать поток кандидатов от HR

Тут имеется в виду, что нужно организовать найм со своей стороны и взаимодействие с заинтересованными сторонами.

выделить время на обработку резюме входящих кандидатов. организовать хранение информации: кто, когда, от кого, текущий статус, комментарии. обратная связь

Потенциально это упражнение может сильно помочь при разборе проблем и работе над ошибками.

Обычно на данном этапе у меня уже есть таблица с портретом аналитика в которой по строкам расписаны критерии оценки и различные пометки, а в столбцах указываются кандидаты

Шаг 3. Просмотр резюме

Как я подхожу к отбору кандидатов на собеседование:

При просмотре поступивших резюме в первую очередь обращаю внимание на системный и комплексный подход. Если этого не прослеживается, то скорее всего кандидату откажу: как потом он сможет описать работу системы, если не может описать себя. Соответствие требованиям, которые ранее давал HR. Если вижу что-то что упустил в требованиях, то правлю запрос. Если кандидат явно не соответствует каким-то обязательным требованиям, то пишу HR отказ с указанием причины. Если в резюме нет явного ответа соответствует ли кандидат требованиям, то задаю уточняющие вопросы HR по этому кандидату. Релевантный опыт. Тут смотрю не только на какой должности работал, но и какие проекты были. Акцент на последние места работы. Если ищу СА на интернет-магазин, а кандидат последние 10 лет внедрял CRM на атомной станции, то кандидат не подойдет. Но такой должен быть отсеян еще рекрутером. Если не отсяен, то даю обратнаю связь. Job-jumping. Я не сторонник частой смены работы, но всегда есть исключения. В среднем считаю нормальным работу в организации от года и более. Развитие. Смотрю на то, как проходит обучение, какие курсы, как часто. Один тренинг личностного роста за 10 лет для СА будет мало. И, наоборот, 10 курсов по различным языкам программирования за последние полгода совмещенные с работой заставят меня задуматься о том, чем кандидат занимался на работе. Адекватность. Если кандидат пишет, что он второй Энштейн и увольняется с работы, т.к. коллеги его не понимают, то скорее всего откажу.

Есть и другие вещи, на которые обращаю внимание, но они уже не такие определяющие. Не буду перечислять, чтобы не обвинили в эйджизме, сексимзме и т.п.:)

Шаг 4. Проведение собеседования

Всем известно, что к собеседованию нужно готовиться, но готовиться нужно не только кандидату, но и нанимающему. Интересное, грамотное собеседование привлечет кандидата. И, наоборот, неподготовленное собеседование может оттолкнуть (скорее даже должно оттолкнуть) хорошего специалиста: зачем лезть туда, где полный бардак?

У каждого свой подход, у меня такой: до того как я начну проводить собеседования, я делаю портрет аналитика (таблицу), прописываю все параметры/вопросы по которым буду оценивать кандидатов, отмечаю обязательные параметры, проставляю коэффициенты по каждому параметру. Получается некая скоринговая модель. И далее провожу собеседования по этой таблице, заполняю оценки и получаю некий балл на выходе. Именно по этому баллу и сравниваю кандидатов.

Если есть в таблице вопрос, то у меня обязательно должен быть краткий ответ, обычно я его там же и записываю в комментарии к ячейке. И, если кандидат не знает ответ, то говорю ему ответ. Считаю это честным подходом, т.к. кандидат тратит свое время и имеет право вынести что-то полезное из собеседования. Плюс такой подход убеждает кандидата, что он сможет развиваться на данном месте. Для многих это значит много. Тут главное не перегнуть палку, чтобы кандидат не вышел с собеседования с обостренным синдромом самозванца.

Что касается составляющих портрета аналитика, то условно таблицу можно разбить на составляющие:

предметная область проекта. Если СА ищется на банковский бэкофис, то можно задавать вопросы, например, ""расскажите структуру банковского счета"" и кандидат должен рассказать про счет первого порядка, счет второго порядка, валюту, ключ, ... для СА, то должен быть блок по управлению требованиями. Туда войдут различные BPMN, UML, ITIL, IDEF, функциональные/нефункциональные требования и т.п. следующий блок по разработке ПО, такие вопросы как жизненный цикл ПО, методологии разработки, тестирование и т.д., следующий блок состоит из технических вопросов специфичных для проекта. Как пример: SSO, REST, HTTP 2.0, регулярные выражения, нормализованная/ денормализованная база данных, автономная транзакция в БД и прочие. вопросы по прикладному ПО. Если на проекте ведется тасктрекинг в Jira, документация в Confluence, API описывает в Swagger, то и кандидат, который является уверенным пользователем данного ПО должен получить больший балл, чем тот, который задачи вел в эксель, документацию в ворде, а API вообще делают разработчики. блок на проверку софтскилов. Тут можно составить некоторый набор вопросов, но также нужно обращать внимание на то, как кандидат отвечает. Обычно обращаю внимание на конфликтность, внимание к деталям, системность мышления, грамотное изложение мыслей. Также предлагаю порефлексировать, порассуждать на тему того, как кандидат сам себя оценивает. Это всегда интересно. критерии оценки работоспособности. Работа СА бывает довольно монотонной, поэтому часто люди выгорают. Очень важно это почувствовать. Также пытаюсь прояснить, что может нести потенциальные риски для работы кандидата, а соответственно и для проекта: от состояния здоровья до вредных привычек. Тут материя тонкая... И даже если спросишь у кандидата прямой вопрос: ""есть ли у вас больные родственники, за которыми нужно круглосуточно ухаживать"", то не факт, что получишь честный ответ. Так что развиваем эмпатию:) вопросы по развитию. Тут про планы, про прочитанные книги и т.д. Делаю это в конце собеседования и смотрю что кандидат скажет. Если кандидат много лет не проходил никакие курсы, а про планы говорит, что вот-вот собирается начать курс по SQL (а раннее не мог ответить на вопрос чем отличается union от union all), то скорее всего я посчитаю, что кандидат лукавит, течет по течению и я ему не поставлю плюсик за развитие но и снижу оценку за честность:) Ну и практические задания. Тут всегда задача на проверку хард-скилов, например, составить json на определенный кейс, или дать строку с регулярным выражением и попросить прочитать ее, или решить задачу на составление sql-запроса с использованием group by having count. Практические задачи всегда разбавляю задачами на сообразительность. Для джунов, в которых планирую вкладываться это часто бывает определяющим.

Само собеседование у меня длится довольно долго, от 1,5 до 2 часов и оно является жестким по формату: вопрос-ответ. Зато кандидат также проверяется на стрессоусточивость. Бывает кандидаты дойдя до практических заданий сдаются и отказываются их делать. А бывают и такие, которые благодарят за собеседование, унося с собой что-то ценное.

Шаг 5. Подведение итогов

Проведя ряд собеседований я сравниваю кандидатов по их оценкам в рамках скоринговой модели и выбираю наилучшего.

P.S.: и в конце хотелось бы отметить, что важно не только найти специалиста, но и удержать его, т.к. цена найма бывает высокая, о чем писал ранее."'https://habr.com/share/publication/720864/3aa74ae1fb6f9edc08f93d3a6814e533/'"['https://habr.com/share/publication/720864/3aa74ae1fb6f9edc08f93d3a6814e533/', 'https://mc.yandex.ru/watch/24049213']"
4'720862'Парсинг данных через api vk и google sheets api на python'Вводная Появилась потребность собирать статистику постов из группы в контакте и затем проанализировать реакции подписчиков на конкретные посты. Если переформулировать на выходе стоит задача с...'https://habr.com/ru/post/720862/'"Вводная

Появилась потребность собирать статистику постов из группы в контакте и затем проанализировать реакции подписчиков на конкретные посты. Если переформулировать на выходе стоит задача с заданной периодичностью снимать показания статистики постов в вк и сохранять их.

Я не профессиональный программист и не претендую, поэтому решил сделать все довольно просто. При помощи api VK забирать посты из группы, собираю нужный мне датафрейм и записываю данные в гугл таблицу, так же через api.

Может быть это и не самое оптимальное решение,

Настраиваем API VK

В этом блоке мы хотим собрать статистику постов из группы vk.

Для начала работы нам нужен user_token из vk. Мне понравилась видеоинструкция здесь, коротко и по делу.

Токен держим в секрете. Переходим в https://dev.vk.com изучаем документацию API.

Нашли подходящий метод wall.get https://dev.vk.com/method/wall.get

Прямо на сайте документации можем попробовать дернуть запрос.

Для этого нам нужно access_token, domain, count, v, filter.

access_token – получили на прошлом шаге. domain – название группы вы увидите в url название группы например https://vk.com/adminsclub. count – количество постов которые можем дернуть. v – версия api. filter – хотим получить только посты от группы устанавливаем owner.

vk можно попробовать, как работает сам метод.

Прописываем логику сбора

Импортируем библиотеку requests. Дергаем тестовый запрос. Поcле анализа структуры решаю, что мне нужен раздел items

# переменные TOKEN_USER = #ваш токен VERSION = #версися api vk DOMAIN = #ваш domain # через api vk вызываем статистику постов response = requests.get('https://api.vk.com/method/wall.get', params={'access_token': TOKEN_USER, 'v': VERSION, 'domain': DOMAIN, 'count': 10, 'filter': str('owner')}) data = response.json()['response']['items']

Отдельное поле в статистики количество фотографий для поста, я не нашел.

Через цикл перебираем каждый пост и считаем количество фото, если фотографии нет скрипт ловит ошибку. Обрабатываем ошибку и ставим 0. Собираем новый список с полями id поста и количество фото.

Пишем обработчик. Вызываем pandas

# считаем сколько фото у поста, заводи все в df id = [] photo = [] for post in data: id.append(post['id']) try: photo.append(len(post['attachments'])) except: photo.append(0) df_photo = pd.DataFrame( {'id': id, 'photo.count': photo, })

Переводим cловарь в df. Импортируем метод from pandas import json_normalize

Оставляем нужные атрибуты и переводим дату в другой формат.

В переменной post_id запихиваем id наших постов.

Я бы хотел обогатить свою статистику более расширенными измерениями

Из документации по api о которой рассказывал выше подобрал метод status.getPostReach

В методе обнаружил новый аргумент owner_id, его можно найти в настройках группы.

Делаем еще один запрос и новые данные сохраняем в датафрейм df_stat_post

# вытаскиваем нужные нам столбцы и переводим формат даты df = json_normalize(data) df = df[['id','date','comments.count','likes.count','reposts.count','reposts.wall_count','reposts.mail_count','views.count','text']] df['date']= [datetime.fromtimestamp(df['date'][i]) for i in range(len(df['date']))] # для каждого поста вытаскиваем дополнительную статистику post_id = ','.join(df['id'].astype(""str"")) response = requests.get('https://api.vk.com/method/stats.getPostReach', params={'access_token': TOKEN_USER, 'v': VERSION, 'owner_id': # ваш id_owner, 'post_ids': post_id}) data = response.json()['response'] df_stat_post = json_normalize(data)

Теперь приступим к сборке объединяем все наши датафреймы, накидываем дополнительные метрики.

Далее наши данные преобразовываем для загрузки в гугл таблицу.

# объединяем все df cо всеми статистиками и количествам фото df_final = df.merge(df_stat_post, how='left', left_on='id', right_on=""post_id"") df_final = df_final.merge(df_photo, how='left', left_on='id', right_on=""id"") df_final.drop(columns='post_id',inplace=True) # добавляем дополнительные столбцы с временем df_final['date_time_report'] = datetime.now() df_final['date_report'] = date.today() df_final['year'] = df_final['date_time_report'].dt.year df_final['month'] = df_final['date_time_report'].dt.month df_final['day'] = df_final['date_time_report'].dt.day df_final['hour'] = df_final['date_time_report'].dt.hour df_final['minute'] = df_final['date_time_report'].dt.minute df_final[['date','date_report','date_time_report']] = df_final[['date','date_report','date_time_report']].astype('str') # сохраняем все значения data_list = df_final.values.tolist()

Грузим в google sheet через api

Есть готовые библиотеки для работы с google sheet например pygsheets , но мне было важно поработать с API поэтому легких путей не искал.

Прежде чем загрузить надо настроить наш api прекрасная статья, в который пошагово написано и даст возможность поиграться с листами https://habr.com/ru/post/483302/

# подключаемся к гугл таблице CREDENTIALS_FILE = # Имя файла с закрытым ключом, вы должны подставить свое # Читаем ключи из файла credentials = ServiceAccountCredentials.from_json_keyfile_name(CREDENTIALS_FILE, ['https://www.googleapis.com/auth/spreadsheets', 'https://www.googleapis.com/auth/drive']) httpAuth = credentials.authorize(httplib2.Http()) # Авторизуемся в системе service = apiclient.discovery.build('sheets', 'v4', http = httpAuth) # Выбираем работу с таблицами и 4 версию API spreadsheetId = # ваш id лист

После подключения к листу. Находим последнюю заполненную строку.

В моем примере я заполняю последние 10 строк ровно по количеству постов которые я получил из get запроса. Подготавливаем шаблон для запроса, заполняем шаблон данными какие ячейки заполняем и заполняем. Далее выполняем запрос. Готово

# находим последнию строку заполненную response = service.spreadsheets().values().get(spreadsheetId = spreadsheetId,range=""Лист номер один!A1:A"").execute() # последние 10 строк заполняем number_sheet = ""Лист номер один!A"" + str(len(response['values'])+1) + ':AA' + str(len(response['values'])+10) # создаем запрос и вставляем туда данные data_vk = { ""valueInputOption"": ""USER_ENTERED"", # Данные воспринимаются, как вводимые пользователем (считается значение формул) ""data"": [ {""range"": """", ""majorDimension"": ""ROWS"", # Сначала заполнять строки, затем столбцы ""values"": ''} ] } data_vk['data'][0]['range'] = number_sheet data_vk['data'][0]['values'] = data_list # выполняем запрос results = service.spreadsheets().values().batchUpdate(spreadsheetId = spreadsheetId, body = data_vk).execute()

Заключение

После написания этого кода мне требовалось запускать его каждый час и принял решение арендовать сервер, установить туда docker и через crontab запускать.

Код на GitHub"'https://habr.com/share/publication/720862/514f877b4b5a299b634767b58b2b019f/'"['https://habr.com/share/publication/720862/514f877b4b5a299b634767b58b2b019f/', 'https://habrastorage.org/r/w780q1/getpro/habr/upload_files/449/688/056/449688056727e7f46227c6c744bba427.jpg', 'https://mc.yandex.ru/watch/24049213', 'https://habrastorage.org/getpro/habr/upload_files/ccc/abf/1e8/cccabf1e817458d8d8a1eb575fbde6e0.JPG']"
5'720848'Тайны мозга. Анализируем данные MRI с помощью FreeSurfer и Python'Визуализация мозга это революционное направление в неврологии, оно позволяет исследователям получать беспрецедентное представление о структуре и функциях человеческого мозга. Одной из областей, где...'https://habr.com/ru/post/720848/'"Визуализация мозга это революционное направление в неврологии, оно позволяет исследователям получать беспрецедентное представление о структуре и функциях человеческого мозга. Одной из областей, где визуализация показала особые перспективы, является выявление паттернов мозговой активности, связанных с различными предрасположенностями, такими как черты личности, когнитивные способности и психические расстройства. В этой статье мы рассмотрим, как эту технологию можно использовать для выявления предрасположенностей человека, и какие открытия были сделаны в этой области, увидим как, используя данные MRI получить сведения о базовых структурах мозга на примере его коры.

Немного теории

Прежде чем мы углубимся в детали, давайте начнем с краткого обзора.



Существует несколько методов, которые можно использовать для визуализации головного мозга, это магнитно-резонансная томография (MRI), функциональная магнитно-резонансная томография (fMRI), позитронно-эмиссионная томография (PET) и электроэнцефалография (EEG). MRI дает подробные изображения структуры мозга, а fMRI, PET и EEG используются для измерения мозговой активности.

Теперь рассмотрим, каким путем можно использовать данные о мозге для вывления предрасположенностей человека.



Один из подходов заключается в изучении мозговой активности людей, проявляющих определенную склонность, и сравнении ее с мозговой активностью тех, у кого такой склонности нет. Например, исследователи могут сравнить мозговую активность людей с высокими баллами по такой черте личности, как экстраверсия, с мозговой активностью тех, у кого низкие баллы. Выявив различия в активности мозга между двумя группами, исследователи могут получить представление о нейронных механизмах, лежащих в основе склонности данного типа.

Другой подход заключается в изучении мозга людей с высоким риском определенной наклонности, например, у людей с семейной историей психических расстройств. Сравнивая мозговую активность этих людей с активностью контрольной группы, исследователи могут определить закономерности мозговой активности, связанные с данным типом наклонности. Этот подход также можно использовать для изучения влияния таких внешних факторов как терапия или лекарства на активность мозга людей этой группы.

Некоторые результаты исследований

Одним из самых захватывающих открытий в области визуализации мозга стало выявление участков мозга, связанных с определенными когнитивными функциями, такими как внимание, память и принятие решений. Например, исследователи определили области мозга, которые активируются, когда людей просят принять решения, связанные с риском и неопределенностью. Эти области были названы «decision-making network», и считается, что они играют ключевую роль в нашей способности принимать сложные решения.

Еще одним захватывающим открытием стала идентификация областей мозга, связанных с конкретными психическими расстройствами. Например, исследователи обнаружили, что у людей с депрессией, как правило, снижается активность префронтальной коры — области мозга, которая участвует в регулировании эмоций и принятии решений. Точно так же люди с тревожными расстройствами, как правило, имеют повышенную активность в миндалевидном теле, области мозга, которая участвует в обработке страха и тревоги.

Визуализация предоставила исследователям мощные инструменты для понимания предрасположенностей человека. Изучая мозг людей, которые проявляют определенную наклонность или подвержены высокому риску ее проявления, исследователи могут выявить закономерности мозговой активности, связанные с этим фактором. Эти идеи уже привели к лучшему пониманию нейронных механизмов, лежащих в основе различных когнитивных функций и психических расстройств. Поскольку технология визуализации мозга продолжает совершенствоваться, мы можем ожидать еще более захватывающие открытия в этой области.

Давайте перейдем к практике, ниже мы узнаем, как мы можем работать с MRI данными. Первый пример покажет как улучшать визуализацию, а второй, как извлекать данные об участках мозга.

Улучшение MRI изображений

Зачастую нам нужно улучшить данные MRI для более четкой визуализации, ниже мы увидим несколько полезных примеров.

Image denoising. MRI зачастую содержит много шума, который снижает качество изображения. Следующий код использует библиотеку NiftyNet для его удаления :

import numpy as np import nibabel as nib from niftynet.engine.application_factory import get_application from niftynet.io.image_reader import ImageReader # Load MRI data reader = ImageReader().initialise({'image': 'path/to/mri.nii.gz'}) data = reader(idx=0)['image_data'] # Apply denoising app = get_application('denoiser') app.net_param.batch_size = 1 app.net_param.validation_every_n = np.inf app.action(data, 'infer') denoised_data = app.output['denoised_data'][0] # Save denoised data nib.save(nib.Nifti1Image(denoised_data, reader.output_path), 'path/to/denoised_mri.nii.gz')

Bias Field Correction. Иногда у нас возникает неоднородность интенсивности MRI сканов, что может снижать качество визуализации. Следующий пример использует библиотеку SimpleITK для коррекции:

import SimpleITK as sitk # Load MRI data mri = sitk.ReadImage('path/to/mri.nii.gz') # Apply bias field correction corrector = sitk.N4BiasFieldCorrectionImageFilter() corrected_mri = corrector.Execute(mri) # Save corrected data sitk.WriteImage(corrected_mri, 'path/to/corrected_mri.nii.gz')

Image Registration. Может использоваться для выравнивания нескольких MRI сканов, что в свою очередь также улучшает качество. Здесь нам также поможет библиотека SimpleITK :

import SimpleITK as sitk # Load MRI data fixed_mri = sitk.ReadImage('path/to/fixed_mri.nii.gz') moving_mri = sitk.ReadImage('path/to/moving_mri.nii.gz') # Perform image registration registration = sitk.ImageRegistrationMethod() registration.SetMetricAsMeanSquares() registration.SetOptimizerAsRegularStepGradientDescent(learningRate=1.0, minStep=0.001, numberOfIterations=200) registration.SetInitialTransform(sitk.TranslationTransform(fixed_mri.GetDimension())) registration.SetInterpolator(sitk.sitkLinear) final_transform = registration.Execute(fixed_mri, moving_mri) # Apply final transform to moving MRI data registered_mri = sitk.Resample(moving_mri, fixed_mri, final_transform, sitk.sitkLinear, 0.0) # Save registered MRI data sitk.WriteImage(registered_mri, 'path/to/registered_mri.nii.gz')

Следует отметить что параметры, используемые в этих примерах, могут нуждаться в корректировке в зависимости от конкретных MRI данных и желаемого результата.

Извлечение данных об участках мозга

Теперь давайте попробуем поработать с MRI c помощью такого замечательного инструмента как FreeSurfer.

Прежде чем мы сможем использовать FreeSurfer, нам необходимо его установить. Инструкция как это сделать. Нам нужно принять условия лицензии и поместить ее в HOME директорию FreeSurfer.

Установив FreeSurfer, мы сможем использовать его для предварительной обработки данных. Вот пример обработки T1-weighted MRI скана:

import os from nipype.interfaces.freesurfer import ReconAll subject_id = 'sub-01' t1w_file = '/path/to/sub-01_T1w.nii.gz' output_dir = '/path/to/freesurfer_output' reconall = ReconAll(subject_id=subject_id, directive='all', T1_files=t1w_file, subjects_dir=output_dir) reconall.run()

Опция directive='all' указывает FreeSurfer выполнить все шаги предварительной обработки, а опция T1_files=t1w_file указывает путь к Т1-weighted MRI скану. Опция subject_dir=output_dir указывает куда поместить результат.

После предварительной обработки мы можем приступим к анализу. Вот пример того, как извлечь данные толщины коры головного мозга:

import os import numpy as np from nibabel import load from nipype.interfaces.freesurfer import SurfaceMetrics subject_id = 'sub-01' hemi = 'lh' output_dir = '/path/to/freesurfer_output' # Load the cortical surface surf_file = os.path.join(output_dir, subject_id, 'surf', f'{hemi}.pial') surf = load(surf_file) # Extract cortical thickness data surface_metrics = SurfaceMetrics(subjects_dir=output_dir) surface_metrics.inputs.hemi = hemi surface_metrics.inputs.subject_id = subject_id surface_metrics.inputs.surface = 'pial' surface_metrics.inputs.curv_measure = 'thickness' thickness_data = np.array(surface_metrics.run().outputs.curv)

Здесь мы загружаем поверхность коры для левого полушария sub-01 и извлекаем данные о толщине коры с помощью SurfaceMetrics . Опция hemi='lh' указывает на левое полушарие, а опция curv_measure='thickness' указывает, что мы хотим извлечь данные о толщине. Результат сохраняется в переменной thickness_data .

Где искать данные для собственных исследований

Есть несколько источников, где вы можете найти нужные данные для исследований и проведения экспериментов:

OpenNeuro — это бесплатная и открытая платформа для обмена MRI данными и иными другими.

Human Connectome Project - это крупномасштабный проект, целью которого является создание карты человеческого мозга с использованием различных методов визуализации.

Brain/MINDS - проект, который фокусируется на маппинге человеческого мозга с пониманием функций его областей.

The Cancer Imaging Archive - является хранилищем медицинских изображений, в том числе MRI данных.

Заключение

Это всего лишь несколько примеров того, как мы можем использовать Python и FreeSurfer для анализа данных MRI. FreeSurfer содержит множество других команд и опций, поэтому обязательно обратитесь к документации для получения дополнительной информации и проведения самостоятельных исследований."'https://habrastorage.org/getpro/habr/upload_files/745/88c/75d/74588c75df712f3f5d6481cf2e529f8e.jpg'"['https://habrastorage.org/getpro/habr/upload_files/745/88c/75d/74588c75df712f3f5d6481cf2e529f8e.jpg', 'https://habrastorage.org/getpro/habr/avatars/f63/735/ca0/f63735ca00e6800c62022a064a0beaae.jpg', 'https://habrastorage.org/r/w32/getpro/habr/avatars/f63/735/ca0/f63735ca00e6800c62022a064a0beaae.jpg', 'https://mc.yandex.ru/watch/24049213']"
6'720846'Как я ставлю задачу для сотрудника'Меня зовут Андрей Глушко. Я менеджер ИТ проектов, занимаюсь менторством, прошёл путь от разработчика до руководителя, в своих подходах опираюсь в первую очередь на людей, а потом уже на практики....'https://habr.com/ru/post/720846/'"Меня зовут Андрей Глушко. Я менеджер ИТ проектов, занимаюсь менторством, прошёл путь от разработчика до руководителя, в своих подходах опираюсь в первую очередь на людей, а потом уже на практики.

Сегодня я хочу поделиться своим подходом в постановке задачи для сотрудника.

На своём опыте я понял, что необходимо найти баланс между вовлечением сотрудника в цели компании и его собственными целями. Поэтому для себя я определил, что важно уметь ставить задачи таким образом, чтобы это затягивало сотрудника в предметную область его позиции и, он осознавал зачем выполняется эта задача в целях бизнеса.

Про цели компании

Для начала я стараюсь выяснить насколько необходимо вовлекать сотрудника в цели проекта или компании. Рассмотрим несколько вариантов:

Если это внештатный сотрудник, с которым я не собираюсь в дальнейшем работать, то постановка задачи в виде инструкций, на мой взгляд, будет самым подходящим вариантом. Нет необходимости создавать дополнительные встречи для обсуждения, чтобы объяснить, как конкретная задача ложится в роадмап фирмы. Я хочу просто получить результат от исполнителя. Если это внештатный сотрудник на тестовом заданий. В таком случае, я уже стараюсь начать вовлекать потенциального сотрудника в дела фирмы и, чтобы он мог принимать самостоятельные решения в случае вопросов, а не постоянно бегать ко мне за уточнениями. Другая ситуация, если это штатный сотрудник. Здесь для меня уже вопрос стоит не в том вовлекать ли сотрудника или нет. В данном случае я оцениваю сколько ему нужно дать информации о целях фирмы, чтобы он мог комфортно осознавать и брать ответственность за свою задачу.

Про постановку задачи

После того как мне стала ясна необходимость и степень вовлечения, для развития высокой лояльности сотрудников в фирме, я определяю детальность постановки задачи. Согласитесь, можно сказать в виде инструкций “Пётр, нам нужно поставить ‘конкретный сервис кеширования’ применив техники ‘техника_1’ и ‘техника_2’”. По сути, таким образом, я забираю у сотрудника мотивацию и желание проявлять инициативность. Однако, бывает и такое, что сотрудник пока что новичок, и если я ему доверю много ответственности, перенеся на его плечи решения по выбору конкретных технологий и методик исполнения вашей задачи, то высок шанс, что он провалит исполнение задачи. Поэтому я делаю следующее:

Определяю насколько развиты hard skills исполнителя. Если это senior, который много повидал и который разбирается в системе компании, будет проще ему делегировать анализ и выбор конкретных решений. И я ставлю задачу в виде бизнес цели, которую необходимо достичь. Опираюсь на зоны ответственности между мной и исполнителем. Независимо от того, насколько у сотрудника сильные hard skills, я стараюсь следить за тем, чтобы не перекладывать на него ту часть ответственности, которая лежит на мне. Ведь если я менеджер проекта, то переносить на программиста обязательство выбора бизнес направлений для решения задачи будет демотивирующим для него. Поэтому я придерживаюсь стратегии дать сотруднику выбор, но при этом не перегрузить его этим выбором. Как следствие, я стараюсь показать ему какие есть рамки бизнес требований, которые необходимо соблюсти при выполнении задач уже на техническом уровне.

Про ресурсы проекта

Заключительным, но не менее важное - я выставляю ресурсные ожидания по выполнению задачи. Как это не печально, но все задания и таски могут быть не выполнены в срок, шанс этого всегда присутствует. Здесь представляется принципиальным для меня, опять же, не перекладывать на сотрудника ответственность за потраченные ресурсы компании. Поэтому я если я знаю, что задача срочная, то времени проводить дополнительные митинги для брейншторма просто нет, и я их не провожу. Как итог, выдаю задачу в виде инструкций. С другой стороны, если я понимаю, что на данный момент у команды есть время и что в случае провала задачи проект не будет на грани, то я уже составляю задачу в более вовлеченной форме для сотрудника.

Подводя итог

На основе моих рассуждений, я создал некоторую классификацию видов постановки задачи для сотрудника, в зависимости от уровня его вовлеченности в бизнесовую часть фирмы:

На уровне бизнес проблемы: “Клиентам важно понимать насколько наше приложение надёжное” Сотрудник, как решение этой проблемы, может внедрить monitoring систему, и он сам принимает решения о выборе способа закрытия проблемы. На уровне бизнес цели: “Мы хотим показать клиентам, что наше приложение надёжное. Это можно сделать через uptime/downtime метрики. {Дальше даются бизнес требования}” Сотрудник уже лучше осознаёт в каком направлении двигаться и как этого можно добиться. На уровне цели исполнителя: “Мы решили, что мы должны ввести uptime/downtime метрики, чтобы клиент лучше понимал насколько у нас надёжное приложение” За сотрудника решили, что конкретно необходимо сделать, на нём остаётся выбор какими инструментами этого он сможет достичь. На уровне инструкций для исполнителя: “Нам нужно ввести monitoring system для расчёта метрик uptime/downtime для нашего приложения. Мы будем имплементировать собственное решение, а не использовать сторонние сервисы. Используй nodejs и чтобы логи шли в elasticsearch, а графики строились через библиотеку chartjs” Тут мало остаётся пространства для самого сотрудника, но и этот вариант подходит в некоторых ситуациях.

Эти виды постановки задачи можно представить в виде простого графика: чем больше сотрудник вовлечён в бизнес, тем меньше ему необходимо детализировать задачу

На этом у меня все. Буду рад обратной связи!"'https://habr.com/share/publication/720846/4fa4e7a687bba4f38074fbd9f91a863a/'"['https://habr.com/share/publication/720846/4fa4e7a687bba4f38074fbd9f91a863a/', 'https://habrastorage.org/r/w1560/getpro/habr/upload_files/b4b/1ab/957/b4b1ab957aa835e90196c8db93ecd3be.png', 'https://mc.yandex.ru/watch/24049213', 'https://habrastorage.org/r/w32/getpro/habr/avatars/9d5/13d/6b9/9d513d6b9f70ff33c144d3e07abbad5b.png', 'https://habrastorage.org/r/w1560/getpro/habr/upload_files/2fb/fe1/0de/2fbfe10dec4fbffc55ea9a30f2973668.png', 'https://habrastorage.org/getpro/habr/avatars/9d5/13d/6b9/9d513d6b9f70ff33c144d3e07abbad5b.png']"
7'720840'Как выиграть ВСОШ по информатике и поступить в ВУЗ мечты?'Привет, меня зовут Сергей Вольнов и я сейчас учусь на первом курсе в НИУ ВШЭ на программе прикладной математики и информатики. Если поступать туда по ЕГЭ, то проходной в этом году был 304 балла по...'https://habr.com/ru/post/720840/'"Привет, меня зовут Сергей Вольнов и я сейчас учусь на первом курсе в НИУ ВШЭ на программе прикладной математики и информатики. Если поступать туда по ЕГЭ, то проходной в этом году был 304 балла по трем предметам, но выиграв олимпиады туда можно без вступительных испытаний.

В 10 и 11 классе я стал призером заключительного этапа Всероссийской Олимпиады Школьников по Информатике (ВСОШ) и даже стал медалистом на международной Жаутыковской олимпиаде по Computer Science. Призерство ВСОШ дало мне возможность поступить в любой ВУЗ на информатическое направление по БВИ и я выбрал ВШЭ.

В этой статье я хотел бы рассказать о том как готовился к олимпиадам по информатике, какие есть кружки/курсы и как правильно вести себя на турах.

Примерно так выглядит счастливый человек, которому больше не нужно думать о ЕГЭ

Немного предыстории

В 6-7 классе я занимался физикой и в конце 7 класса даже стал призером заключительного этапа олимпиады Максвелла по физике (что-то типо ВСОШ для младших классов). С 8 класса (агрессивно с 9) я ботал олимпиадную информатику и в итоге в 10 и 11 классах стал призером ВСОШ по информатике. Я не считаю себя каким-то мега-гением, а скорее думаю, что при должном усилие заботать можно все - осталось лишь приложить усилие.

Олимпиадная информатика VS жизнь

Вообще, олимпиадная информатике довольно сильно отличается от обычной. Весь мир олимпиадной информатике крутится вокруг различных алгоритмов и структур данных, чтобы уметь считать какие-то вещи оптимально. В обычной разработке с этими алгоритмами сталкиваешься куда реже и в сильно меньшем объеме по сравнению со школьными олимпиадами, но уметь применять базовые алгоритмы все равно необходимо (+ их часто спрашивают на собеседованиях). Так что эта статья может быть полезна и тем, кто просто решил подтянуть свои знания в этой области, но не знает с чего начать.

Все ресурсы подготовки к ВСОШ можно разделить на три основных блока: курсы и кружки, олимпиадные смены и летние школы и онлайн ресурсы для самоподготовки. Давайте сейчас подробнее рассмотрим каждый из этих блоков.

Курсы и кружки по подготовке

Обычно курсы составляют наибольшую часть подготовки, так как это занятия на постоянной основе, включающие в себя как практику так и теорию, так что поступить на хорошие курсы это уже половина пути к вашей победе. Ниже я подробно расскажу о тех курсах, которые проходил сам и оставлю ссылочки на те ресурсы, о которых только слышал.

Tinkoff Generation | Оффлайн/Онлайн

Однозначно лучший из курсов, который я проходил. Занятия проходят раз в неделю по 5 часов, на неделю дается контест с задачами на пройденную тему, есть разборы и дорешки контестов, а так же семинары на которых решаете теоретические задачи. Еще есть возможность писать дистанционные туры и в принципе крутое олимпиадное комьюнити.

Есть несколько уровней сложности: C, B', B, A', A, каждый уровень - годовой курс. Свой первый всерос я взял, пройдя B' и B. Сам курс бесплатный, но для поступления нужно решить отборочный контест, который проходит в конце августа или пройти донабор в начале январе. За анонсами можно следить в их телеграмм канале.

Кружки от ЦПМ | Оффлайн

В 9 классе ходил на кружок в центр педагогического мастерства (ЦПМ). Сами занятия были выстроены хорошо, но одного этого кружка было бы маловат, так как это всего 3 часа в неделю (для сравнения, в Тинькоффе 5 часов в неделю) и контесты в качестве домашнего задания меньше. Думаю, может быть неплохим вариантов в качестве дополнительного кружка.

Занятия в школе | Оффлайн

Иногда в школах есть свои кружки по информатике - их качество может сильно варьироваться в зависимости от школы, но мне повезло и у меня был очень сильный кружок (я учился в Физтех-лицее им П. Л. Капицы), в который я ходил в 10 классе. Возможно в вашей школе тоже есть что-то такое.

Ссылочки на разные кружки/курсы, в которых сам не занимался

Онлайн ресурсы для самостоятельной подготовки

Вообще есть довольно много ресурсов, где можно решать алгоритмические задачи (LeetCode, Informatics, Timus и тд), но я за время своей подготовки пользовался в основном Codeforces и чуть-чуть Informatics (для прорешивания туров ВСОШ прошлых лет).

Codeforces это сайт, на котором пару раз в неделю проводятся микро соревнования, которые можно писать для тренировки в ""боевых условиях"". Также имеется довольно большой архив задач для самостоятельной подготовки. Всем советую его решать, так как это является хорошим приближением (по формату) разных олимпиадок + дополнительная практика.

Образовательные интенсивы

Помимо кружков и курсов есть еще один распространенный формат подготовки - это различные летние школы, сборы и образовательные смены. Их суть заключается в том, чтобы в короткие сроки (обычно 2-3 недели) дать максимум подготовки. Каждый день у вас есть много пар связанных с олимпиадным программированием, которые зачастую делятся на два типа: вначале идет лекция, а потом решаете контест на пройденную тему + дорешка в свободное время. Обычно вся эта активности идет с утра и часов до 17 (дальше отдых), так что бота реально много, но и прокачивает хорошо.

Олимпиадные школы от МФТИ (ЛОШ/ЗОШ) | 2 недели, Платно

Это была моя первая олимпиадная школа, в которую я поехал летом после 8-ого класса. Я бы посоветовал ее именно в качестве начального варианта, так как туда не очень сложный отбор и довольно неплохой уровень обучения. Так что это хорошая возможность подготовиться к отборочным во всякие кружки по типу Тинькоффа (которые проходят в конце лета), ведь чтобы в них пройти нужно уже иметь некоторый бэкграунд.

Сириус | 3 недели, Бесплатно

Возможно вы про него уже где-то слышали, но для тех, кто нет - это такой образовательный центр в Сочи, с очень сильным преподавательским составом и классными условиями проживания. Он проводит смены по разным направлениям несколько раз в год, в том числе и информатике. Актуальные смены можно отслеживать на их сайте.

Сам был в нем 3 раза на информатических и 2 раза на физических сменах. Для того, чтобы туда попасть нужно пройти отбор (не очень легкий) или уже показать хорошие результаты на региональном/заключительном этапе. Может хорошо прокачать даже опытных олимпиадников, так что всем советую мониторить его программы и подаваться.

Летняя Компьютерная Школа (ЛКШ) | 2 недели, Платно

Сильная олимпиадная школа, о которой не раз слышал хорошие отзывы. Сам в нее прошел в 9 классе, но ее в том году отменили из-за ковида, так что съездить не смог, а в 10 уже и сам всерос взял. Сложность отборочного варьируется в зависимости от того на какую параллель хотите ехать, так что можно подобрать под себя. Отбор проходит где-то в начале мая.

ШОП Иннополис | 7-10 дней, Платно

Ездил один раз в 10 классе. Если честно, не очень помню подробности, но вроде было нормально.

Региональные Сборы | 1-2 недели, Бесплатно

В многих регионах, в частности в московской области, проводятся сборы по подготовке к региональному и/или заключительному этапу ВСОШ. Для того, чтобы на них попасть нужно просто выйти на соответствующий этап и подать заявку через сайт. Вообще, советую не упускать шанса лишний раз подготовиться, так что если у вас в регионе такое проводят, то участвуйте.

Ссылочки на разные интенсивы, в которых сам не занимался

Как ботать эффективно?

Курсы и интенсивы можно проходить по-разному. Буквально один совет, чтобы повысить эффект от курсов в несколько раз: ❗️Дорешивайте задачи❗️. Если вы просто решаете задачи, то применяете те знания, что уже у вас есть, а если вы его после разбора дорешиваете, то узнаете кучу нового. Я это осознал только к 10 классу и стал полностью закрывать контесты на дорешке - реально в разы эффективнее.

Во многих кружках и школах проводятся разборы, так что остается только закодить (просто осознать разбор сильно хуже откладывается в голове). На codeforces можете дорешивать только те задачи, над которыми успели подумать во время раунда (разборы там тоже публикуются). В общем не пренебрегайте этим сильным инструментом.

Поведение на турах

Безусловно, подготовка играет решающую роль в твоей победе на олимпиаде, однако когда дело доходит до написания самого тура очень важно выложится на максимум и показать всю силу своих скиллов. Реальные условия олимпиады зачастую отличаются от тех, в которых ты готовился: много стресса, строгое ограничение по времени и высокое значение самой олимпиады явно не упрощают процесс написания контента. Поэтому в этой части я расскажу о том, какие приемы использовал во время написания туров в боевых условиях и как выложится на свой максимум.

До тура

Для начала разберем, что стоит делать, когда тур еще не начался, но уже на носу.

Во-первых, настройте себе режим дня заранее! Очень часто замечал, что люди всю неделю до тура идут спать после 00, а в последний день такие ""лягу в 22, завтра ведь в 6 утра вставать"". В итоге ложились и просто не могли заснуть до часу ночи, а потом писали региональный этап, поспав 5 часов. Не надо так)

Во-вторых, за день до тура (а лучше за два) ботать запрещено, чтобы дать мозгу отдохнуть - все равно перед смертью не надышишься. В идеале просто много гулять, можно поиграть в настольные/спортивные игры или позаниматься еще чем-нибудь, что не требует больших умственных усилий.

Перед туром нужно хорошо поесть, чтобы хватило надолго (в идеале где-то за час до тура). В дополнение к шоколадкам на олимпиаду мне еще нравилось брать чай с сахаром (быстрые углеводы) и какую-нибудь булочку, так как на одном шоколаде может быть сложно 5 часов писать тур.

Еще я перед туром съедал по 3 аскорбинки, так как однажды услышал от одного препода, что они разгоняют мозг немного. 99%, что это полная лажа, но тем не менее я их ел))

На туре

Теперь давайте пройдемся по основным правилам, которыми я старался следовать на турах и о которых я не раз слышал от своих преподавателей.

Важно: основная цель на туре это не решить много задач, а набрать много баллов. После тура не должно быть ни одной подгруппы, которая ""легкая, но просто прочитал в последние 5 минут и не успел решить"". Если задача не идет - переключитесь и повыбивайте баллы где можете (она в фоне все равно будет думаться). Выход в туалет - отличный способ проветриться, не стоит им пренебрегать. К середине тура не должно быть ни одной непрочитанной задачи. Если задачка не придумывается сходу, то хорошей практикой будет решать ее по подгруппам, так как часто жюри их делают так, чтобы они подводили к полному решению. Чтобы меньше нервничать мне помогала следующая парадигма: ""моя задача решить на мой максимум, чтобы я ни о чем не жалел после тура, а остальное от меня не зависит (стану ли я в итоге призером/победителем или нет)"". В таком случае, даже если в этом году загробили B, то ты сможешь переключиться, а не загоняться по этому поводу весь раунд и решать B на полный балл вместо выбивания баллов.

Тайминги по решение задач на туре

На региональном этапе хорошей стратегией может оказаться следующая:

1. A и B решаете за первые час-два

2. Потом закрываете все подгруппы, который можете в D

3. Оставшееся время спокойно решаете C.

На заключительном этапе:

1. A и B решаете за первые час-два (если B не идет, то можно переключится на D)

2. Потом закрываете все подгруппы, который можете в D

3. Оставшееся время спокойно решаете C (и B, если еще не дорешали ее).

Второй тур

На второй нужно идти так, будто это первый, опять решать все на максимум и никак не ориентироваться на баллы первого тура. Второй тур очень сильно влияет, так что даже после успешного первого тура можно все слить и после слитого перого тура можно все вытащить. В остальном советы такие же, как и для первого дня.

Заключение

В этой статье я постарался как можно подробнее рассказать о ресурсах и трюках, которые помогли мне стать призером Всероссийской Олимпиады Школьников по информатике и надеюсь они помогут вам. Всем успехов!

P.S. Еще я веду канал в телеграмме - буду рад всех там видеть)"'https://habrastorage.org/getpro/habr/upload_files/398/35e/c2e/39835ec2eafa001dc357388986363fc0.jpg'"['https://habrastorage.org/getpro/habr/avatars/810/fbf/dd0/810fbfdd029e5e7b0511164385479481.jpg', 'https://habrastorage.org/r/w32/getpro/habr/avatars/810/fbf/dd0/810fbfdd029e5e7b0511164385479481.jpg', 'https://habrastorage.org/getpro/habr/upload_files/398/35e/c2e/39835ec2eafa001dc357388986363fc0.jpg', 'https://habrastorage.org/r/w780q1/getpro/habr/upload_files/398/35e/c2e/39835ec2eafa001dc357388986363fc0.jpg', 'https://mc.yandex.ru/watch/24049213']"
8'714292'КПК HP iPaq, Дюма 1870 года и PCMCIA факс-модем: новые находки на испанской барахолке'Привет, Хабр! В это воскресенье была хорошая погода, что порадовало, поскольку прогноз изначально был не особо оптимистичным. Но, как говорится, «пронесло», и я снова отправился в поисках интересных...'https://habr.com/ru/post/714292/'"Где продавцы берут свой товар?

Ну а теперь — к товарам!

Класс: бизнес (middle end);

Положение в линейке: под HP iPaq hx2190;

Операционная система: Windows Mobile 5.0 for Pocket PC;

Процессор: Samsung SC32442 300 МГц;

Оперативная память: 32 Мб (23.68 Мб доступно пользователю);

ПЗУ: 64 Мб (35.07 Мб доступно пользователю);

Расширяемость: SD/MMC-слот (поддержка SDIO), Wi-Fi (IEEE 802.11b), USB 1.1 клиент (зарядка, синхронизация), COM (Serial RS232), IrDA (SIR);

Экран: TFT 3.5” (активная область – 53.5x71мм) c разрешением 320х240 точек, отображает 65 тысяч цветов;

Батарея: съемная Li-Ion емкостью 1100 мАч;

Габариты: 113.6x70.6x13.5 мм;

Вес: 125 г.

Что это за штука?

Привет, Хабр! В это воскресенье была хорошая погода, что порадовало, поскольку прогноз изначально был не особо оптимистичным. Но, как говорится, «пронесло», и я снова отправился в поисках интересных гаджетов на барахолку под Валенсией. Напомню, это одна из самых больших барахолок, что я видел, она тянется по одной из улиц на несколько километров. Соответственно, интересных вещей там тоже море, от антиквариата до более-менее новых устройств.В конце статьи — угадайка «Что это за штука». Мне всегда попадаются вещи, которые я не могу распознать с первого взгляда, поэтому давайте попробуем угадать их предназначение вместе. Ну что, поехали!В комментариях я не раз и не два видел предположения, что на этой барахолке «ворованное все и вся». Также спрашивали, наведывается ли полиция на блошиный рынок для проверки товаров. Для того, чтобы прояснить этот вопрос, в свой текущий визит поговорил с парой продавцов.Они мне рассказали, что 80% товара на барахолке, если речь не про антиквариат вроде мечей, ваз, картин, очень старых проигрывателей винила и все такое прочее, имеет два пути происхождения. Продавцы с рынка занимаются вывозом хлама из помещений, которые продаются, либо сдаются в аренду. Кто-то из них покупает этот хлам огромными объемами потом распределяет, кому-то он достается бесплатно, просто за то, что продавец убирает помещение. И владельцу/покупателю помещения не приходится тратить на утилизацию всего этого места.Какие помещения имеются в виду? Дома, владелец которых умер или уехал навсегда и продает дом удаленно. Арендные офисы, чьи владельцы не проплатили аренду за несколько месяцев и скрылись и все такое прочее. Есть и сотрудники puntos limpio — туда свозят на утилизацию электронику и бытовую технику, а сотрудники выбирают себе, что получше. И потом не утилизируют, а продают или оставляют себе. Вроде и не прямо на 100% легально, но уж совершенно точно не криминал.Есть, вероятно, и ворованные вещи, но было бы странно полагать, что вор залез в квартиру или дом, рискуя свободой, для того, чтобы потом продать ворованные вещи за копейки, да еще и не скупщику краденого, а на открытом для всех общественном блошином рынке. Как бы там ни было, барахолка — официальное мероприятие городка, в котором она проводится. Мне говорили, что полиция часто прохаживается по рядам, но не в форме, а в гражданской одежде. Насколько это правда — не берусь судить, но про полицию в «гражданке» слышал и раньше. Если кто-то вызывают подозрение, его тихонечко проверяют.В общем, как-то так.Почти в самом начале рынка попался на глаза чей-то набор компонентов для ремонта техники. В наборе самые разные конденсаторы, транзисторы, резисторы, переключатели, провода и все такое прочее. Вряд ли человек, который собирал все это не первый год, взял и в один прекрасный момент выбросил. Скорее всего, либо что-то с этим человеком случилось, либо же он решил продать дом, а весь этот набор в новое жилище не перевез. Так это сокровище и попало на барахолку — его вывезли «уборщики», о чем говорил выше.Потом увидел вот такой веротолет. Он просто огромный, если сравнивать с вертолетиками для детей обычного размера. Этот уже не для детей, а, вероятно, подростков и взрослых. Ну просто потому, что такие лопасти могут натворить много бед, если не быть очень внимательным, на что дети по умолчанию не способны. Во всяком случае, большинство. Стоит, правда, не так, чтобы очень много — на одном из российских маркетплейсов его цена составляет 3490 рублей. Я у продавца цену не спрашивал, поскольку такой вертолет мне не нужен. Но размер впечатляет, конечно.Чуть подальше были квадрокоптеры и прочие дроны. Некоторые с пультами, другие — без, но выглядели они не особо работоспособными.Потом из интересного — вот этот микроскоп с набором предметных стекол. Насколько я понимаю, это простой прибор, для школьников и студентов. Ну, может, его используют и в лабораториях, где не нужно очень большое увеличение. Если вы с такой моделью сталкивались — напишите, как она вам.Еще чуть подальше — робот для чистки бассейнов. Я подобный как-то видел, когда был на отдыхе в Турции. Это было довольно давно, и уже тогда они были популярны. Сейчас, вероятно, они по-прежнему актуальны, продолжая трудиться на благо отелей и частных лиц под водой. Стоимость таких устройств не особо скромная, так что можно предположить, что конкретно этот робот либо сломался, либо же его хранили где-то, после чего помещение очистили, а то, что было внутри — выставили на продажу.Удачная находка — вот эти два КПК, это HP iPaq rx1950. Продавались с чехлами, проводами для подключения к ПК, док-станциями и картами памяти с файлами навигатора TomTom.Вот характеристики этой модели Кстати, док-станции необычные, я таких раньше не видел — в том плане, что они позволяют заряжать не только сам девайс, но и просто аккумуляторы к нему. Например, если есть запасная батарейка, то одна может заряжаться внутри КПК, а вторая — отдельно, будучи подключенной к док-станции.Оба КПК при подключении не заряжались. Но это типично, поскольку они могли пролежать где-то в офисном складе бог знает сколько времени, много-много лет. Когда аккумулятор высаживается в ноль, то контроллер многих моделей батарей не дает им заряжаться, считая аккумулятор мертвым. На самом деле, нужно найти на батарейке плюс и минус, и подключить их к лабораторному источнику питания или вообще к любому питанию 5 В. Очень желательно иметь возможность ограничить ток зарядки, поскольку иначе аккумулятор может перегреться и в итоге вообще загореться. У меня такого ни разу не было, но, возможно, именно потому, что я всегда выставляю ограничение по току — примерно 1-1,5А. Полностью заряжать не нужно, достаточно будет подождать с минуту, и все — аккумулятор можно ставить на место и устанавливать девайс в док-станцию для зарядки. Среди ремонтников подобный заряд батареи называется «толкнуть аккумулятор».Как только я «толкнул» оба, КПК стали заряжаться и потом заработали. Оба в идеальном состоянии, никаких личных файлов нет ни на одном из них. У меня такое впечатление, что их не использовали. И да, оба — с Windows CE на британском, плюс таким же часовым поясом.Рядом лежал вот такой PCMCI факс-модем. Ценная штука для своего времени. Помню, я использовал PCMCI-модуль в одном из ноутбуков без Ethernet-порта, он меня очень сильно выручил тогда. Это не Ethernet, но тоже нужная штука, модель PCMCIA PC CARD Fax/modem Dynalink 1456CS 56kbps.Потом встретился новый физически привод для Xbox 360. Его даже не открывали — он в состоянии «только что из магазина». Почему его выкинули — загадка. Вероятно, просто товар был не слишком популярным, и после того, как Xbox 360 сменило следующее поколение консолей, эти приводы стали сдавать на пункты утилизации. Ну или кто-то себе купил, но девайс не пригодился.Еще встретилась целая гора разных клавиатур, среди которых — эргономическая клавиатура от Microsoft. Я очень уважаю клавиатуры этой компании, после того, как приобрел Microsoft Sculpt, она прослужила верой и правдой много лет, пока ее не сменила split-клавиатура.Прямо день клавиатур, по-другому и не скажешь. На барахолке в разные дни случаются перекосы в пользу тех или иных категорий товаров. То какие-то спортивные снаряды, то пишущие машинки, то дроны, а сейчас вот — клавиатуры. Кстати, если говорить о пишущих машинках, то встретилась вот такая.Посмотрел — до сих пор продается в разных магазинах, от онлайн-аукционов до обычных магазинов электроники. Цена от 20 евро и до 90. Не знаю, кто такое покупает, но явно товар еще пользуется спросом.А вот и оборудование для передачи данных. Это шлюз Xacom Celline As. Характеристики:1 канал связи GSMИнтерфейс для аналогового телефона или линии коммутатора PBXПоследовательный порт для передачи данных (ПК/ФАКС)Отправка и получение компьютерного факса (PC FAX)SMS-сервер для отправки и получения SMS-сообщенийСовместимость с SIM-картой любого оператора.Вот описание из сети. Xacom Celline As — одноканальный аналоговый GSM-шлюз, предоставляющий пользователю эффективный способ связи и снижающий стоимость звонков в сети GSM. Celline AS предназначена для малых и средних компаний. Подключается к местной телефонной станции и может использоваться для передачи голоса и сигналов данных по GPRS, SMS.Потом вот такая камера, Panasonic MS4.Записывала все на кассеты vhs и S-VHS. Популярной была в 90-е годы, тогда стоила кучу денег. Сейчас они практически не используются, поскольку формат носителей сейчас совсем другой. Но на онлайн-барахолках, включая российские, этот девайс все еще продается. Стоимость примерно 100-150 евро.Да, на глаза еще попался винтажный немецкий барометр. Честно говоря, не знаю, какой год — не смог найти информацию на корпусе. Но выглядит, как будто бы он сделан в середине XX века, возможно, и раньше.Кстати, раньше я публиковал фото кирас, причем самых настоящих, тоже продающихся на барахолке. А сейчас вот увидел рапиры (это же они?), причем у продавца, который совершенно точно не занимается антиквариатом. Состояние их ужасное, но, возможно, еще подлежат восстановлению.Нельзя было пропустить и еще один антиквариат, на этот раз книжный. Это книга MEMORIAS DE UN MÉDICO TOMO PRIMERO (A. Dumas) Murcia y Martí, 1870. Честно говоря, думал, что встретился редкий экземпляр, поскольку для меня любая книга из 19 века — нечто очень ценное. Но нет, нашел онлайн-ресурс, где то же самое продается за 7 евро. Даже обидно стало — почему так дешево? Неужели этих книг было напечатано столько, что к нам дошли тысячи и тысячи?Ну и еще попалось множество музыкальных инструментов, плюс мексиканские шляпы, маракасы и еще спиртометр, которым можно определять градус напитка. Все, что нужно для праздника!Как всегда, попалось несколько вещей, о которых я представления не имею — что это и зачем. Давайте попробуем разобраться вместе.Теннисная вроде как ракетка, зажатая между двух деревянных трапеций. Я бы посчитал, что это какая-то ненужная самоделка, но нет, при мне ее купила женщина за 10 евро. Зачем, почему? Одни вопросы. Возможно, сама ракетка представляет ценность, и если ее вынуть из рамок, то можно получить ценный трофей?Очевидно, какой-то пульт. Но от чего он и почему такой формы?Здесь даже предположений нет, для чего подобное может служить. Явно не музыкальный инструмент, но что это?Какой-то специализированный молоток. Но почему у него резиновая накладка только с одной стороны? Так и нужно, или вторая просто отвалилась? И вообще, для чего такой молоток нужен — укладывать плитку?Очень загадочная штука c интригующим названием Intimus Simplex. Внутри нее ничего нет.Штука № 6Тут все более-менее понятно, музыкальный инструмент. Но это игрушка или реальный инструмент? Если последнее, то как он называется?Ну а на сегодня все, не переключайтесь!"'https://habr.com/share/publication/714292/b1a2185af76fd9f0d1adc15121868b85/'"['https://habrastorage.org/r/w780q1/webt/c8/jg/z5/c8jgz50kxvrva91pu244hv1blgi.jpeg', 'https://habrastorage.org/r/w780q1/webt/dv/dw/_i/dvdw_icszxum1fkwfgge7kurwga.jpeg', 'https://habrastorage.org/r/w780q1/webt/pj/qw/8e/pjqw8eitbts9y71cpg8fmzly0kw.jpeg', 'https://habrastorage.org/r/w780q1/webt/dc/59/lt/dc59lt2w1sx7kdpabu64dio4exs.jpeg', 'https://habrastorage.org/r/w780q1/webt/jt/n6/b_/jtn6b_muf4rwjdewpmku22lal44.jpeg', 'https://habrastorage.org/r/w780q1/webt/uo/ut/5y/uout5yj284e6twhg-utqk9lc_-e.jpeg', 'https://habr.com/share/publication/714292/b1a2185af76fd9f0d1adc15121868b85/', 'https://habrastorage.org/r/w780q1/webt/qn/7l/4w/qn7l4wh9z19ioxmaz_h9rexy3j4.jpeg', 'https://habrastorage.org/r/w780q1/webt/xp/3o/8d/xp3o8dbsblq0ih1nchm-v4dfyoe.jpeg', 'https://habrastorage.org/r/w780q1/webt/vq/yp/sz/vqypszcfedb-erbtbppnbjqm2ii.jpeg', 'https://habrastorage.org/r/w780q1/webt/fs/rg/zb/fsrgzbvompdgsjlpjh8gzvh3zow.jpeg', 'https://habrastorage.org/r/w1560/webt/pt/wt/-p/ptwt-pcef2msq7duvzrwfkt4gbo.png', 'https://habrastorage.org/r/w780q1/webt/nc/0s/6e/nc0s6er-jupnsjziugvejznfwto.jpeg', 'https://habrastorage.org/r/w780q1/webt/z-/pr/jn/z-prjnqwyi_31jfmc3glqzna9pq.jpeg', 'https://habrastorage.org/r/w780q1/webt/pj/eh/3k/pjeh3kqwgxgtoimhm8dx95krnmu.jpeg', 'https://habrastorage.org/r/w780q1/webt/3o/gz/eg/3ogzegtygxmqptjwzjsbvvxxy4m.jpeg', 'https://habrastorage.org/r/w780q1/webt/d7/b_/yu/d7b_yugbqlni4x7lbt3jjcfmbtg.jpeg', 'https://habrastorage.org/r/w780q1/webt/lq/oq/ik/lqoqikbstsjchvd2nvvoxezih8m.jpeg', 'https://habrastorage.org/r/w780q1/webt/w8/ar/7s/w8ar7sfqsamuuzskfezwglrc61o.jpeg', 'https://habrastorage.org/r/w780q1/webt/3s/9u/zj/3s9uzj8jwjyy3ruwilnxdm-nhgo.jpeg', 'https://habrastorage.org/r/w780q1/webt/_6/1n/i5/_61ni59bnp5-7melsipobrxin1u.jpeg', 'https://habrastorage.org/getpro/habr/company/66a/f7d/039/66af7d03979b6d18654293d8f1e72837.png', 'https://habrastorage.org/r/w32/getpro/habr/avatars/126/32f/feb/12632ffebec0f851ba0ec665f3ed6c55.jpg', 'https://habrastorage.org/r/w780q1/webt/zv/rj/tt/zvrjttpjoaclnlz-_wyqmstz7ry.jpeg', 'https://habrastorage.org/r/w780q1/webt/pl/fy/gk/plfygkrzrakd1pfmxnvot4xsk6s.jpeg', 'https://habrastorage.org/r/w780q1/webt/rb/ad/zo/rbadzohiryypjwulfuuntja5r6w.jpeg', 'https://mc.yandex.ru/watch/24049213', 'https://habrastorage.org/r/w780q1/webt/ux/nk/-s/uxnk-spp3ljg2eo-m9_cqr7xs60.jpeg', 'https://habrastorage.org/r/w780q1/webt/f7/yh/7v/f7yh7vdyzsth3wbxnhae7z0txkw.jpeg', 'https://habrastorage.org/r/w780q1/webt/sa/nz/0s/sanz0swvsuxqw_k5o6n7rju25o8.jpeg', 'https://habrastorage.org/r/w780q1/webt/oy/oo/4j/oyoo4jbqb4z_qfxviep_w4hgrfw.jpeg', 'https://habrastorage.org/r/w780q1/webt/b9/xm/t8/b9xmt8io1ouawooqvba1s4gqzfg.jpeg', 'https://habrastorage.org/r/w780q1/webt/ox/ni/1a/oxni1aasl5jt0-cxz5bwz8d9jnu.jpeg', 'https://habrastorage.org/getpro/habr/avatars/126/32f/feb/12632ffebec0f851ba0ec665f3ed6c55.jpg', 'https://habrastorage.org/r/w780q1/webt/ix/4d/85/ix4d85sdtvbkh67odszuradwzxo.jpeg', 'https://habrastorage.org/r/w780q1/webt/nc/la/gx/nclagxonwnayhug2suszpyiygae.jpeg', 'https://habrastorage.org/r/w780q1/webt/2s/qu/tz/2squtzt8x_sd4gcqzaqscf-h4q0.jpeg', 'https://habrastorage.org/r/w780q1/webt/i-/wf/cc/i-wfcctzgukuyodfdcfwxrkhkcs.jpeg', 'https://habrastorage.org/r/w780q1/webt/zc/cm/2s/zccm2sbyyga7p-ryvyrobqsjumw.jpeg', 'https://habrastorage.org/r/w780q1/webt/gu/ru/2l/guru2lp6biutnjcbhfx-xcj9nxq.jpeg', 'https://habrastorage.org/r/w780q1/webt/km/yw/ze/kmywze4gibkcssajqi_ut-okiza.jpeg']"
9'720834'Apple Pro Weekly News (27.02 – 05.03.23)'Apple приостановила ремонт Mac и iPad в России, а также заплатила штраф по решению ФАС, но из российского App Store пропала ещё пачка приложений. Что компания выпустит в самое ближайшее время, когда...'https://habr.com/ru/post/720834/'"Apple приостановила ремонт Mac и iPad в России, а также заплатила штраф по решению ФАС, но из российского App Store пропала ещё пачка приложений. Что компания выпустит в самое ближайшее время, когда новые Mac на чипе M3 и что компания предлагает теперь разработчикам приложений. Эти и другие важные новости вокруг Apple – в нашем новом дайджесте.

Вторые бета-версии для тестировщиков, а также новые инструменты для разработчиков приложений

На прошедшей неделе вышли вторые беты для разработчиков:

• iOS 16.4 Beta 2 (20E5223e)

• iPadOS 16.4 Beta 2 (20E5223e)

• tvOS 16.4 Beta 2 (20L5474e)

• HomePod 16.4 Beta 2 (20L5474e)

• watchOS 9.4 Beta 2 (20T5233d)

• macOS Ventura 13.3 Beta 2 (22E5230e)

• Studio Display 16.4 Beta 2 (20E5223e) (Установка доступна только на macOS 13.3 beta)

Для пользователей iOS 16.4 beta также стало доступно тестовое обновление безопасности iOS Security Response (a) (20E7752230f) – ничего важного особо оно в себе не несёт, но таким способом компания обкатывает функцию для дальнейшей реализации.

Ну и конечно же, системы также доступны в качестве публичной бета-версии для участников программы паблик-теста от Apple.

Установка пока доступна по профилю конфигурации, однако скоро это изменится и профиль не будет нужен

Что нового в этой бета-версии?

Возвращение классической анимации листания в «Книгах»

В разделе «Действие гарантии» были добавлены иконки устройств

В коде системы найдено упоминание поддержки Pay в Южной Корее – Apple готовилась к запуску платежного сервиса в этой стране с 2017 года, и в феврале этого года было получено одобрение южнокорейской Комиссии по финансовым услугам.

Зарисовка: а если бы МИР поддерживался где-то, например, в Корее. Но пока, увы, его функциональности нет даже у нас.

Найдены в коде беты и следы Apple Music Classical – «для прослушивания Apple Music Classical требуется установить Apple Music». Судя по всему, релиз нового приложения с классической музыкой ожидается этой весной. А ещё, Apple работает над добавлением функции для медицинских учреждений – Clinical Notes в приложении Здоровье. В коде системы найдена поддержка системных клавиатур QWERTY для языков чикасо и чокто (коренные народы на юге США). А в коде tvOS 16.4 beta найдены упоминания скорого запуска Siri для HomePod и tv на иврите. Также обозначена поддержка HomePod в Израиле.

Ожидаемая дата релиза новых систем - конец марта.

А тем временем, Apple запустила настоящий бенчмарк для приложений. Компания запускает для разработчиков новый инструмент в App Store Connect для сравнения производительности приложений с аналогами.

Новые тесты Peer Group позволяют разработчикам анализировать использование, монетизацию и многое другое через кабинет аналитики в App Store Connect. Информация поможет принимать более правильные решения касательно распространения приложений и реализации новых возможностей внутри системы.

В АСЦ на территории России временно не принимают в ремонт Mac и iPad

С 3 марта в Авторизованных Сервисных Центрах Apple на территории России на неопределенный срок остановлен процесс приёма в ремонт яблочных компьютеров и планшетов. В настоящий момент технику смогут принять лишь на диагностику и мелкие косметические процедуры. В случае серьёзной неисправности, даже по гарантии, вам возможно, предложат обратиться по месту приобретения за возвратом средств.

Это связано с процессом перехода ремонтной системы в России на новые каналы поставки запчастей и элементов обслуживания (по нашим данным – это продлится до лета этого года). После изменений, в обозримом будущем, ожидается возобновление ремонтного обслуживания, пусть и в ограниченном порядке.

С остальной продукцией, кроме компьютеров Mac и iPad – сейчас проблем не наблюдается, ремонт производится при обращении в АСЦ без изменений.

В случае неисправностей с вашими Mac или iPad - для начала обратитесь в Поддержку Apple

Apple заплатила штраф, выписанный ФАС РФ

Уведомление об оплате штрафа появилось на сайте ФАС. 22 февраля сумма в размере 906 299 392₽ была оплачена в счёт предписания по штрафу за «злоупотребление доминирующим положением на рынке распространения мобильных приложений на операционной системе iOS, путём совершения ряда действий, предоставлявших конкурентное преимущество собственным продуктам и ухудшение условий распространения продуктов конкурентов – в частности, приложений родительского контроля».

Начало всей истории здесь.

Рубрика «На этой неделе могли скачать из App Store, но не скачали»

2 марта в App Store перестали быть доступны приложения ряда подсанкционных банков (и не только). Потеряли пользователи доступ к достаточно внушительному перечню классных, качественных и передовых по технологиям приложениям. Итак, какие приложения на прошлой неделе стали недоступны для загрузки и установки в российском App Store:

• Тинькофф банк: мобильный банк

• Тинькофф Бизнес

• Тинькофф Инвестиции

• Тинькофф Бухгалтерия

• Тинькофф Мобайл

• Тинькофф Подпись

• Тинькофф Журнал

• Академия Инвестиций Тинькофф

• Долями: оплата частями

• Уралсиб Онлайн

• Уралсиб Бизнес

• Уралсиб QR для Бизнеса

• Зенит Онлайн

• ЗЕНИТ Бизнес

• Банк Левобережный

• BL Business Банк Левобережный

• Онлайн-офис BL-Online

• BL Бизнес iBank

• СДМ Бизнес

• Мобильный банк Приморье

• METIB-Online (Металлинвест)

• METIB Business

• METIB Инвестор

• МТС Банк

• МТС Банк NEW

• МТС Pay

• DJI Fly

• DJI GO 4

• DJI Store – Buy First Here

• DJI GO

• DJI Ronin

• DJI Mimo

• DJI Assistant

• Sports.ru: новости спорта (все, включая 20 тематических)

Если у вас установлены данные приложения – не удаляйте их, скачать их заново вы не сможете!

Зато стали доступные новые версии приложений для некоторых банков и сервисов, которые уже давно под санкциями. Например, для пользователей ВТБ предлагается новое приложение «Всё просто», а для тех, кому необходимо приложение Дом Клик от Сбера – «ДКлик» в App Store ждёт вас. Если вы пользователь Совкомбанка-Халва карта – «Все Карты MDS». Для клиентов Московского Крединого Банка (МКБ) – пока что доступно «К Деньгам».

Будем следить за развитием событий и обязательно сообщим об изменениях в каталоге приложений в следующих выпусках дайджеста.

Слухи: iPhone 14 в жёлтом цвете, утекли передние стёкла iPhone 15 и когда выйдут новые MacBook

Соскучились по жёлтому iPhone? По слухам, новым цветом в линейке iPhone 14 и iPhone 14 Plus этой весной может стать жёлтый. Причём выпустить его могут прямо на этой неделе, так что ожидаем новостей!

Концепт жёлтого iPhone 14

Согласно свежему патенту Apple на технологию размещения в WATCH, AirPods, iPhone и даже гарнитуре смешанной реальности, датчиков для отслеживания здоровья, компания планирует масштабно развернуть новые датчики во всех носимых устройствах в ближайшем будущем.

Патент Apple на датчики здоровья в Apple Watch и iPhone (© Patently Apple)

Предполагается размещение датчиков различного типа. Например, неоптические пьезоэлектрические или акустические, инфракрасные или светодиодные датчики.

Патент на размещение и работу датчиков измерения состояния здоровья в различных гарнитурах (© Patently Apple)

Например, в гарнитуре смешанной реальности это может позволить измерить температуру между двумя ушами путем измерения теплового потока между двумя ушами с помощью датчиков температуры.

А свежая утечка передних панелей iPhone 15 серии подтверждает, что «динамический островок» получат все модели в линейке.

Также можно заметить более тонкие рамки в версии стекла для Pro-версий устройства

Новые Mac на чипах M3 могут выйти уже в конце весны или даже летом! По слухам, обновлённый 24-дюймовый iMac уже на чипе M3 ожидается во второй половине этого года. Также новые MacBook на новом чипе уже находятся на продвинутой стадии разработки. Apple может представить MacBook Air 13” и 15” сразу на чипе M3, возможно, уже даже на WWDC23.

Самый долгожданный iMac на чипах M3 также получит и новую цветовую палитру. Как вам такой лавандовый вариант?

Для любителей мониторов и аккуратного стола: Anker выпустили уникальную подставку под монитор с 12 портами

Производитель аксессуаров выпустил удивительную штуку, которая сочетает в себе удобство использования внешнего монитора для Mac, имеет функционал хаба с кабель-менеджментом и одновременно зарядки iPhone.

Подставка-хаб под названием Anker 675 USB-C Docking Station – включает в себя 11 портов, а именно: USB-C/Thunderbolt 4 (100W), USB-C (10Gbps, 45W), USB-A 3.1 gen 2 (10Gbps), Ethernet 1Gbps, HDMI 4K@60Hz, SD/microSD слоты (UHS-I) и miniJack 3,5mm. А также справа установлена площадка для беспроводной зарядки по стандарту Qi (до 10W) для зарядки вашего iPhone.

У стильной алюминиевой док-станции заявлена поддержка macOS и Windows. Что примечательно – поддерживает одновременную работу всех портов сразу, а для питания ей потребуется адаптер на 180W.

Многофункциональная подставка-хаб уже в продаже на официальном сайте Anker по цене от $250.

Apple поделилась результатами исследования здоровья женщин и причём тут WATCH

В преддверии Международного женского дня компания Apple поделилась результатами своего масштабного исследования здоровья женщин «Apple Women's Health Study».

Уже сейчас в Apple Watch Series 8 есть функционал прогнозирования цикла при помощи датчика температуры тела

Результаты подчеркивают важность уделения внимания менструальным циклам и их связи с общим здоровьем женщин. Совместно с Гарвардской школой общественного здравоохранения и Национальным институтом наук о гигиене окружающей среды, были изучены показатели владельцев WATCH с рядом диагнозов, таких как: нерегулярность циклов, синдром поликистозных яичников, риски рака матки, бесплодие, процессы в менопаузе. Благодаря части полученных данных (а их более 125 000) – исследователи обнаружили ценные данные для дальнейших изучений медицинскими специалистами.

Таким образом, благодаря использованию приложения Здоровье на iPhone и WATCH, исследовательской группе будет проще провести анализ данных для научной публикации и последующего установления возможности обнаружения тех или иных заболеваний у женщин. Это также поможет совершенствовать систему мониторинга менструальных циклов.

Кстати, владельцы (все) WATCH смогут заработать награду «Международный Женский день» и анимированные стикеры iMessage, выполнив 8 марта любую тренировку длительностью 20 минут и более!

Награда станет доступна для получения именно 8 марта всем владельцам Apple Watch

Мы обязательно уведомим о челлендже в наших социальных сетях, где также оперативно выходят различные новости обо всём вокруг Apple (и не только):

Twitter / Telegram / VK"'https://habrastorage.org/getpro/habr/upload_files/62c/52e/08b/62c52e08b203ca5ed03804fe9d46ed22.jpeg'"['https://habrastorage.org/r/w780q1/getpro/habr/upload_files/ed0/df7/b36/ed0df7b360eeedb17b55c35ad731b9d1.jpeg', 'https://habrastorage.org/r/w780q1/getpro/habr/upload_files/6a2/e47/9fa/6a2e479fa9ef581ae4ea3ceabe457796.jpeg', 'https://habrastorage.org/r/w780q1/getpro/habr/upload_files/ab3/441/d88/ab3441d88e9a83493dc8192add771b66.jpeg', 'https://habrastorage.org/getpro/habr/avatars/6c7/234/254/6c723425499b09b2554dbed3e5a246ad.jpg', 'https://habrastorage.org/r/w780q1/getpro/habr/upload_files/46b/211/aa6/46b211aa6967a79ffff9509a59aa1a3f.jpeg', 'https://habrastorage.org/r/w780q1/getpro/habr/upload_files/b2b/d65/01a/b2bd6501a2f3967075759761392d0968.jpeg', 'https://habrastorage.org/r/w780q1/getpro/habr/upload_files/1bc/6c6/7d7/1bc6c67d74843611421ad412f2d353df.jpeg', 'https://habrastorage.org/r/w780q1/getpro/habr/upload_files/34b/20b/396/34b20b3966b850ecd4c25703e027ac3b.jpeg', 'https://habrastorage.org/r/w780q1/getpro/habr/upload_files/6b1/1a1/26f/6b11a126f7aab8bb915e761af272a01c.jpeg', 'https://habrastorage.org/r/w780q1/getpro/habr/upload_files/07e/75a/bda/07e75abda33e8a67d86d76345ebe15fe.jpeg', 'https://habrastorage.org/r/w780q1/getpro/habr/upload_files/cb4/f72/e05/cb4f72e051fee2006de860601f9c8de8.jpeg', 'https://habrastorage.org/r/w780q1/getpro/habr/upload_files/f6e/ade/0dd/f6eade0dd3730dafb550375beefe9bfd.jpeg', 'https://habrastorage.org/r/w780q1/getpro/habr/upload_files/f3b/967/218/f3b9672185147052fbaf697e5d31b628.jpeg', 'https://mc.yandex.ru/watch/24049213', 'https://habrastorage.org/r/w780q1/getpro/habr/upload_files/884/663/863/884663863a26cfc3f63e01dec807401e.jpeg', 'https://habrastorage.org/getpro/habr/upload_files/62c/52e/08b/62c52e08b203ca5ed03804fe9d46ed22.jpeg', 'https://habrastorage.org/r/w780q1/getpro/habr/upload_files/a45/26f/69b/a4526f69beac729f42a673c75ecb362f.jpeg', 'https://habrastorage.org/r/w780q1/getpro/habr/upload_files/163/6ba/262/1636ba262083fe0a554e63bebb419832.jpeg', 'https://habrastorage.org/r/w780q1/getpro/habr/upload_files/cc4/92c/bcb/cc492cbcb367debeee7d528a79748f57.jpeg', 'https://habrastorage.org/r/w780q1/getpro/habr/upload_files/34b/b43/d30/34bb43d301f8081d180cfa25615a6820.jpeg', 'https://habrastorage.org/r/w32/getpro/habr/avatars/6c7/234/254/6c723425499b09b2554dbed3e5a246ad.jpg', 'https://habrastorage.org/r/w780q1/getpro/habr/upload_files/97a/371/0a9/97a3710a9833dfec2810aa248868cf18.jpeg']"
10'720562'Доработка фильтра обратного осмоса'Как-то в пору жаркого лета жена обратила мое внимание на странный привкус воды, которая текла после фильтра. У нас был установлен трех секционный проточный фильтр под мойку, а для питья мы...'https://habr.com/ru/post/720562/'"Как-то в пору жаркого лета жена обратила мое внимание на странный привкус воды, которая текла после фильтра. У нас был установлен трех секционный проточный фильтр под мойку, а для питья мы пользовались еще и дополнительным фильтром в кувшине.

Хотя фильтры под мойкой менялись не очень давно, я решил поменять их еще раз, и к своему ужасу увидел неприглядную картину, примерно вот такую:

А так как колбы фильтров были не прозрачные, то заранее увидеть весь этот ужас было невозможно. И не смотря на то, что я руководствовался рекомендациями производителя по срокам замены фильтров, сюрприз вышел очень неприятный.

После этого пришлось озаботится получением чистой воды, которая идет на приготовление пищи и питье. Только в этот раз решил подумать, прежде чем бездумно выполнять рекомендации производителей и вестись на их рекламные общения.

И к своем неудовольствию, я не нашел такого предложения, которое бы меня устраивало! В итоге после некоторых размышлений, решил немного доработать фильтр обратного осмоса, о котором и хочу рассказать.

Как вы уже поняли, я решил заменить старый фильтр на установку с обратным осмосом — полупроницаемой мембраной, через которую под давлением проходят только молекулы воды, а все примеси сливаются в канализацию. Такие фильтры обеспечивают наверно самую качественную степень очистки, вот только их цена кусается.

Размышления на тему выбора нового фильтра

Как правило, для дома предлагаются фильтры с мембраной обратного осмоса, которые имеют от трех до пяти картриджей — несколько фильтров предварительной очистки, мембрану обратного осмоса и угольный постфильтр, цена которых колеблется от 8 до 20 тыс.руб.

Если бы речь шла только о разовой покупке, то однократно такую стоимость можно и заплатить, но ведь фильтры на замену тоже стоят денег! А они меняются по несколько раз в год (мембрана обратного осмоса немного реже — один раз в 1 — 1,5 года). А картриджи в фильтрах нужно заменять каждые 3-4 месяца (комплект сменных картриджей обходится 1 — 3 тыс.руб), что выглядят немного разорительно.

И хотя на воде (и здоровье) не экономят, но меня заинтересовал вопрос, почему практически у всех производителей для предварительной фильтрации перед мембраной обратного осмоса стоят два угольных фильтра? Ведь от них мало толку, так как степень очистки мембраной гораздо выше. А потом до меня дошло, расходники! Ведь при наличии предварительных фильтров, производители вынуждают их постоянно менять, хотя по большому счету от них нет никакого толку!

Реальная польза наверно есть только от постфильтра тонкой очистки, но и тут не все просто. В большинстве случаев постфильтры выполненные в отдельном небольшом корпусе, в котором меняется не кассета, а весь фильтр целиком! А это тоже не сказывается на уменьшении стоимости расходников.

Но ведь раз подобные решения не приносят пользы потребителю, то наверно в них заинтересован производитель? После этого все встало на свои места и родился следующий план по доработке фильтра с целью уменьшения периодических расходов без ухудшения потребительских свойств.

Что мне хотелось от нового фильтра?

Так как каждый производитель хочет привязать потребителя к использованию только своей продукции (не совместимые посадочные места или размеры элементов), то таких производителей в топку. Нужно покупать только такой фильтр, в котором используются стандартные и широко распространённые расходные материалы (например, мембраны обратного осмоса 1812).



Хотя бы у первого фильтра грубой очистки колба должна быть прозрачной, чтобы можно было визуально контролировать степень его загрязнения для своевременной замены.



Так как для фильтра с обратным осмосом два предварительных угольных фильтра нужны как собаке пятая нога, решил переключить один из них для работы в качестве постфильтра, а штатный постфильтр с не сменным картриджем вообще выкинуть. Но тут нужно аккуратно выбирать, так как некоторые производители делают такие корпуса, в которых изменить порядок подключения фильтров не получится (как на картинке ниже)!



В результате получилась следующая схема соединения:

Соединение последовательности подключения фильтров до переделки:



Соединение фильтров после переделки:



Правая колба на фотографиях была переключена на работу в качестве постфильтра. Вся работа заняла примерно 5 минут (дольше искал фитинг для соединения двух трубок).

Итоговый результат:



Результаты измерения минерализации воды. Вода из под крана, вода после фильтра кувшина, и вода после фильтра с мембраной обратного осмоса.

Степень минерализации воды 50 ppm – идеальная для употребления вода

до 170 ppm – безопасная вода, имеет незначительную минерализацию

до 300 ppm – водопроводная вода, имеющая повышенную жесткость. Считается условно безопасной

до 400 ppm – необработанная жидкость из источника

до 500 ppm и выше – потенциально опасная для употребления вода

В результате получилась точно такая же степень очистки, что и до переделки, но с существенной экономией расходников, так как в предварительном фильтре оставил только два картриджа для грубой очистки (они существенно дешевле и их достаточно для предварительной очистки перед мембраной) и не нужно покупать отдельный постфильтр, так как вместо него используется обычная кассета с более дешевым с угольным картриджем, у которого еще и ресурс значительно больше из-за большего размера."'https://habr.com/share/publication/720562/87434d21f4a9b2a2d38f9caef4b65bca/'"['https://habrastorage.org/r/w780q1/webt/sl/oq/tj/sloqtjqbdyewm0ddk0dm8hb7qes.jpeg', 'https://habrastorage.org/r/w780q1/webt/4_/us/y0/4_usy0iuyh9nu2rs8v7i8p5rdgc.jpeg', 'https://habrastorage.org/r/w780q1/webt/iv/rp/bf/ivrpbf3ejubp6e1p7fq9t-fm7z8.jpeg', 'https://habrastorage.org/r/w780q1/webt/i7/yj/2d/i7yj2drq9uk9uexoaq6tzkek-w0.jpeg', 'https://mc.yandex.ru/watch/24049213', 'https://habr.com/share/publication/720562/87434d21f4a9b2a2d38f9caef4b65bca/', 'https://habrastorage.org/r/w780q1/webt/fo/kz/zo/fokzzoc62hj1e5oefahdpsotkuo.jpeg', 'https://habrastorage.org/r/w780q1/webt/si/y9/kx/siy9kxhagrrbzwir5sgrcyuabym.jpeg']"
11'720786'Поправки в закон о государственном языке: ответы для предпринимателей и айтишников'С 28 февраля 2023 г. вступила в силу новая редакция Федерального закона № 53-ФЗ «О государственном языке Российской Федерации». Как пишут в большинстве обзоров, закон направлен на ограничение...'https://habr.com/ru/post/720786/'"С 28 февраля 2023 г. вступила в силу новая редакция Федерального закона № 53-ФЗ «О государственном языке Российской Федерации». Как пишут в большинстве обзоров, закон направлен на ограничение использования иностранных слов государственными органами. Однако фактически установленные законом запретительные меры шире и определяют, в частности, обязательность использования русского языка в информации, предназначенной для потребителей товаров (работ, услуг).

При этом новая редакция Федерального закона № 53-ФЗ совершенно четко и недвусмысленно определяет, как именно будет определяться корректность использования русского языка. Именно, как гласит п. 6 ст. 1 закона, при использовании государственного языка Российской Федерации не допускается употребление:

иностранных слов, за исключением тех, перечень которых содержится в нормативных словарях (и которые не имеют общеупотребительных аналогов в русском языке) слов и выражений, не соответствующих нормам современного русского литературного языка (каковые нормы также определяются нормативными словарями, справочниками и грамматиками).

То есть, если вы на этикетке совершенно по-русски написали краткую информацию о товаре — каждое слово в этом тексте должно соответствовать утвержденным нормативным словарям, справочникам и грамматикам.

Но, возможно, все не так строго, и сложность исполнения закона смягчается теми или иными обстоятельствами? Попробуем разобраться более детально.

Информация для потребителей: о чем идет речь

Обязательные сферы использования государственного языка Российской Федерации определяются статьей 3 Федерального закона № 53-ФЗ. В действующей редакции закона к ранее перечисленным сферам обязательного применения русского языка были добавлены:

Образование (с учетом особенностей, установленных ФЗ № 273 «Об образовании в Российской Федерации») Государственные и муниципальные информационные системы Информация, предназначенная для потребителей товаров (работ, услуг)

Наиболее важный для бизнеса пункт — безусловно, в части информации для потребителей товаров (работ, услуг). Понять, о какой конкретно информации идет речь, можно с помощью статьи 10 «Информация о товарах (работах, услугах)» Закона «О защите прав потребителей». В соответствии с п. 2 указанной статьи, информация о товарах (работах, услугах) в обязательном порядке должна содержать:

сведения об основных потребительских свойствах товаров (работ, услуг);

цену в рублях и условия приобретения товаров (работ, услуг), в том числе при оплате товаров (работ, услуг) через определенное время после их передачи (выполнения, оказания) потребителю, полную сумму, подлежащую выплате потребителем, и график погашения этой суммы;

гарантийный срок, если он установлен;

правила и условия эффективного и безопасного использования товаров (работ, услуг);

срок службы или срок годности товаров (работ), а также сведения о необходимых действиях потребителя по истечении указанных сроков и возможных последствиях при невыполнении таких действий, если товары (работы) по истечении указанных сроков представляют опасность для жизни, здоровья и имущества потребителя или становятся непригодными для использования по назначению;

адрес (место нахождения), фирменное наименование (наименование) изготовителя (исполнителя, продавца), уполномоченной организации или уполномоченного индивидуального предпринимателя, импортера;

информацию о правилах продажи товаров (выполнения работ, оказания услуг);

указание на конкретное лицо, которое будет выполнять работу (оказывать услугу), и информацию о нем, если это имеет значение, исходя из характера работы (услуги);

наименование технического регламента или иное установленное законодательством РФ о техническом регулировании и свидетельствующее об обязательном подтверждении соответствия товара обозначение;

указание на использование фонограмм при оказании развлекательных услуг исполнителями музыкальных произведений.

Для отдельных категорий товаров в состав обязательной информации также входит информация об энергетической эффективности товаров (в соответствии с законодательством об энергосбережении и о повышении энергетической эффективности), информация об обязательном подтверждении соответствия товаров (работ, услуг). В отношении продуктов питания в состав обязательной информации входят также сведения:

о составе, в том числе наименование использованных в процессе изготовления продуктов питания пищевых добавок, биологически активных добавок, информация о наличии в продуктах питания компонентов, полученных с применением генно-инженерно-модифицированных организмов, в случае, если содержание указанных организмов в таком компоненте составляет более девяти десятых процента,

о пищевой ценности,

о назначении,

об условиях применения и хранения продуктов питания,

о способах изготовления готовых блюд,

о весе (объеме),

о дате и месте изготовления и упаковки (расфасовки),

о противопоказаниях для их применения при отдельных заболеваниях.

В соответствии с новой редакцией Федерального закона № 53-ФЗ «О государственном языке Российской Федерации», каждое слово и фраза, использованные для предоставления вышеуказанной обязательной информации, должно соответствовать нормам современного русского литературного языка. Проверка соответствия, следуя букве закона, осуществляется вполне прямолинейно — в соответствии с наличием таких слов в утвержденном перечне нормативных словарей, справочников и грамматик.

При использовании же слов на иностранном языке, в соответствии с п. 2 ст. 3 Федерального закона, вам необходимо будет непосредственно на той же позиции размещения, в том же цвете и размере шрифта привести аналогичную подпись на русском языке — примерно так, как это делается на дорожных указателях, выполненных сразу на нескольких языках. В качестве приятной ремарки, стоит отметить, что в отношении слов и фраз на иностранных языках иммунитетом к дублированию на русском языке по-прежнему наделены товарные знаки, знаки обслуживания и фирменные наименования — в соответствии с п. 3 ст. 3 Федерального закона № 53-ФЗ.

А судьи кто? О нормативных словарях

Первая мысль, возникающая при упоминании некоторого «утвержденного списка» в отношении недавно принятых поправок — вероятно, этот список еще не утвердили, и, нельзя такое исключать, еще пока неизвестен даже порядок его утверждения. Но не в этом случае.

Широкий интерес к закону о государственном языке возникает не в первый раз. Кодификация «норм современного русского языка» состоялась четыре года назад, в 2009 г. Именно в это время Приказом Министерства образования и науки РФ от 08 июня 2009 г. № 195 был утвержден Список грамматик, словарей и справочников, содержащих нормы современного русского литературного языка при его использовании в качестве государственного языка Российской Федерации. В список вошли:

Орфографический словарь русского языка. Букчина Б.З., Сазонова И.К., Чельцова Л.К. - М: ""АСТ-ПРЕСС"", 2008. - 1288 с. Грамматический словарь русского языка: Словоизменение. Зализняк А.А. - М.: ""АСТ-ПРЕСС"" 2008. - 794 с. Словарь ударений русского языка. Резниченко И.Л. - М.: "" АСТ-ПРЕСС"", 2008. - 943 с. Большой фразеологический словарь русского языка. Значение. Употребление. Культурологический комментарий. Телия В.Н. - М.: ""АСТ-ПРЕСС"", 2008. - 782 с.

Состав этого списка вызвал бурю вопросов. Как можно видеть, в список не вошел, например, очевидно ожидаемый (бывшим) рядовым российским школьником словарь Ожегова — и более профессиональный, и очевидно уважаемый в профессиональным сообществе «Русский орфографический словарь» под редакцией В. В. Лопатина.

В сущности, в список не вошел ни один популярный, знакомый гражданам России словарь. Даже и сейчас, на волне интереса к последствиям принятия нового закона, в число самых популярных словарей вошли словарь Ожегова, Ушакова и Даля, но почему-то отнюдь не четыре словаря издания «АСТ-ПРЕСС». С которыми, кроме всего прочего, невозможно ознакомиться онлайн — даже путем скачивания пиратских, всячески нарушающих интеллектуальные права авторов и издательства копий. Их просто-напросто нет, да и купить эти словари, вышедшие весьма ограниченным тиражом, на популярных сайтах не представляется возможным.

В том же 2009 г., после того, как волна общественного возмущения стала немного затихать, уже в рамках отдельных мероприятий разъяснялось, как случилось так, что в список попали всего четыре словаря, и те одного издательства. Как рассказывала М. Л. Каленчук, заместитель директора по научной работе Института русского языка им. В. В. Виноградова РАН, для экспертизы словарей были отобраны пять компетентных экспертных организаций, в число которых вошли филфак МГУ, филфак Санкт-Петербургского университета, Институт русского языка им. Виноградова РАН, Институт лингвистических исследований РАН и Институт русского языка им. Пушкина. Дальнейшая процедура была максимально упрощена: «Автор или издатель должен сам выбирать экспертную организацию. Издательство напрямую заключает договор с экспертной организацией, оно напрямую взаимодействует с экспертами, само оплачивает рецензию и приносит уже подписанное заключение в Межведомственную комиссию по русскому языку, которая должна принять окончательное решение. <…> Случайно получилось, что первыми на экспертизу были поданы четыре словаря издательства «АСТ-Пресс». Никакой подоплеки за этим не стоит. <…> Уверена, что в ближайшее время и другие издательства попробуют включить свои словари в федеральный перечень».

Дальше, правда, ничего не случилось. Список нормативных словарей безо всяких изменений просуществовал вплоть до 28 февраля 2023 г., вплоть до даты вступления в силу новой редакции Федерального закона № 53-ФЗ. Характеристики же четырех единственных нормативных словарей, регулирующих теперь все нормы современного русского литературного языка — совершенно не изменились.

Не претендуя на детальность исследования «О словарях, ""содержащих нормы современного русского литературного языка при его использовании в качестве государственного языка Российской Федерации""» за авторством ведущего научного сотрудника Института русского языка им. В. В. Виноградова РАН доктора филологических наук Владимира Ивановича Беликова, с которым можно ознакомиться на сайте Грамота.ру , воспроизведем лишь несколько его ключевых тезисов:

Словари с библиографическими данными, приведенными в Приказе № 195 от 08 июня 2009 г., отсутствуют в реальном мире. При этом очевидно, что разные издания словарей даже одних и тех же авторов могут и будут содержать различия. Использовать можно только тот словарь, который приведен в Приказе, но таких словарей не существует. Словари, перечисленные в Приказе, являются далеко не самыми полными из возможных. В частности, «Орфографический словарь русского языка» (Букчина Б.З., Сазонова И.К., Чельцова Л.К.) — содержит всего около 100 000 слов, количество весьма незначительное. Так, широко признанный в профессиональном сообществе «Русский орфографический словарь» под редакцией В. В. Лопатина — содержит около 180 000 слов, то есть почти в два раза больше. Не все приведенные в списке словари в принципе являются словарями в принятом общеупотребительном значении. «Большой фразеологический словарь русского языка» авторства В. Н. Телия является, скорее, культурологическим изданием, и содержит весьма свободные фразеологизмы, включая, например, такие, как «отпетый дурак», «базарная баба» и «дать дуба».

***

Таким образом, следует с прискорбием заключить, что использование в официальной переписке обращения «отпетый дурак» не будет противоречить нормам современного русского языка, содержащимся в нормативных словарях, а вот использование слова «бренд», отсутствующего в Орфографическом словаре русского языка, является теперь недопустимой вольностью при использовании государственного языка Российской Федерации.

Что же делать?

В условиях, когда практически невозможно ознакомиться со словарями, которые, вне зависимости от вопросов к их содержанию, сейчас являются единственными определяющими нормы современного русского литературного языка при его использовании в качестве государственного языка Российской Федерации — практические действия предпринимателей по исполнению требований об использовании в информации, предназначенной для потребителей товаров (работ, услуг), исключительно слов, входящих в указанные словари, не поддаются осмыслению.

Для полноты картины стоит процитировать Решение Верховного Суда РФ от 13 мая 2020 г. № АКПИ20-142, касающегося все той же проблемы невозможности ознакомления со словарями (истцу отказали в изменении названия некоммерческой организации в связи с использованием в этом названии иностранного слова): «Доводы административного истца о невозможности ознакомления с соответствующими справочниками сами по себе не свидетельствуют о незаконности Постановления № 714. Доступ граждан к словарям, включённым в Список грамматик, словарей и справочников, содержащих нормы современного литературного языка при его использовании в качестве государственного языка Российской Федерации, утверждённый приказом Министерства образования и науки Российской Федерации от 8 июня 2009 г. N 195, обеспечивается законодательством Российской Федерации».

Стоит надеяться, что такой доступ действительно будет в ближайшее время обеспечен, либо же расширен список словарей. С другой стороны, возможно и повторение сценария 2009 г., когда после бурного и длительного общественного обсуждения вопрос просто сошел на нет в связи с отсутствием фактической ответственности за нарушение Федерального закона № 53-ФЗ. Ведь в статье 6 Федерального закона сказано, что «нарушение настоящего Федерального закона влечет за собой ответственность, установленную законодательством Российской Федерации», однако эта ответственность до сих пор не определена."'https://habrastorage.org/getpro/habr/upload_files/1e1/eb6/64c/1e1eb664c33513c422439ad427909aa8.png'"['https://habrastorage.org/getpro/habr/avatars/28d/3ca/22b/28d3ca22b7fcb7e077cc19d1a9b4cb8b.jpg', 'https://habrastorage.org/getpro/habr/company/post_desktop/5a5/23f/069/5a523f0690db172e81f2a0d65bcefbf4.png', 'https://vk.com/rtrg?p=VK-RTRG-1669144-8I6Rb', 'https://habrastorage.org/r/w1560/getpro/habr/upload_files/1e1/eb6/64c/1e1eb664c33513c422439ad427909aa8.png', 'https://habrastorage.org/getpro/habr/branding/77e/913/273/77e913273854c5e4ce598bda9d498c69.png', 'https://habrastorage.org/getpro/habr/upload_files/1e1/eb6/64c/1e1eb664c33513c422439ad427909aa8.png', 'https://mc.yandex.ru/watch/24049213', 'https://habrastorage.org/getpro/habr/company/3a0/49e/ff5/3a049eff5348e0517954069b5a7c61e2.png', 'https://habrastorage.org/r/w32/getpro/habr/avatars/28d/3ca/22b/28d3ca22b7fcb7e077cc19d1a9b4cb8b.jpg']"
12'720708'Security Week 2310: безопасность квадрокоптеров DJI'На прошлой неделе исследователи из Рурского университета в Бохуме опубликовали научную работу , посвященную безопасности квадрокоптеров DJI. Анализ устройств проводился при помощи реверс-инжиниринга...'https://habr.com/ru/post/720708/'На прошлой неделе исследователи из Рурского университета в Бохуме опубликовали научную работу , посвященную безопасности квадрокоптеров DJI. Анализ устройств проводился при помощи реверс-инжиниринга прошивок, фаззинга и исследования протоколов коммуникаций. В результате ученые нашли 16 уязвимостей, которые производитель закрыл через день после публикации работы.Всего в исследовании приняли участие три модели дронов DJI: DJI Mini 2, Mavic Air 2 и Mavic 2 Pro. Ученые также проанализировали две модели пультов управления, которые идут в комплекте с этими квадрокоптерами. Позднее выяснилось, что все найденные проблемы также актуальны и для более свежей модели Mavic 3. В рамках работы энтузиасты изучили все способы взаимодействия с устройствами, включая USB, UART, беспроводную связь (Bluetooth, Wi-Fi и проприетарный стандарт Ocusync), приложения для смартфона, а также собственный протокол коммуникации DJI Universal Markup Language.Прежде всего исследователи рассмотрели работу фичи, которая публично не задокументирована и ранее не изучалась. Помимо коммуникаций с оператором (через пульт или приложение для телефона), квадрокоптеры DJI на отдельной частоте передают так называемый DroneID. С помощью этих данных правоохранительные органы могут идентифицировать дроны там, где их использование запрещено. Чтобы проанализировать этот метод коммуникации и определить формат передаваемых пакетов данных, пришлось изучить прошивку устройства. Как выяснилось, DroneID передается в незашифрованном виде и раскрывает локацию как самого устройства, так и его оператора. Ученые также рассмотрели сценарий, при котором оператор дрона пытается скрыть как минимум собственное местоположение. В этом случае работают традиционные методы подмены геоданных на смартфоне: фейковые координаты, судя по всему, передаются через приложение DJI на квадрокоптер и дальше транслируются в составе пакетов DroneID.Исследователи также построили оригинальную инфраструктуру для поиска уязвимостей в ПО квадрокоптера методом фаззинга. Чтобы ускорить процесс тестирования, на устройство одним пакетом отправляли 130 тысяч команд. Фаззер адаптировали для работы с проприетарным протоколом коммуникации DJI Universal Markup Language. Чтобы проверить, работает ли дрон после такого блока команд, ученые придумали особую схему: если устройство «падало», большой блок команд делили на более мелкие. Несколько итераций таких последовательных проверок помогали найти точное число запросов, которое вызвало повреждение данных на устройстве или отказ в обслуживании.Фаззинг помог выявить 15 уязвимостей, большинство из которых вызывают исключительно отказ в обслуживании. Но в двух случаях авторы работы нашли способ выполнить произвольный код на устройстве. Примечательно, что часть обнаруженных уязвимостей можно было эксплуатировать удаленно, в процессе коммуникации между дроном, пультом дистанционного управления и смартфоном. Одна из уязвимостей также позволяет менять серийный номер устройства, что противоречит модели безопасности, заявленной производителем.К сожалению, на момент подготовки материала компания DJI не выпустила никаких бюллетеней с подробным описанием уязвимостей и их квалификацией. О том, что проблемы решены, мы знаем только из пресс-релиза на сайте Рурского университета. В самой научной работе есть оценка всех 15 проблем, найденных с помощью фаззинга, с уровнем опасности не более «среднего» (что в целом логично, так как речь идет об атаке с привязанного к устройству пульта управления и/или смартфона). Не очень понятно, будет ли DJI делать что-то с коммуникацией DroneID открытым текстом в радиоэфире. Авторы работы при этом обозначают наиболее привлекательный сценарий для атаки: когда сторонний наблюдатель может манипулировать квадрокоптером. В исследовании говорится о теоретической возможности такой атаки, но конкретных примеров показать не удалось. Наибольший интерес в работе, таким образом, представляет не опасность обнаруженных уязвимостей (хотя потенциал для дальнейших исследований существует), а комплексный подход к исследованию безопасности квадрокоптеров. В нашем случае это комбинация разных методов — от фаззинга до статического анализа прошивок и перехвата беспроводных коммуникаций.Свежий отчет «Лаборатории Касперского» посвящен эволюции угроз для промышленных систем автоматизации за второе полугодие 2022 года.Разработчики менеджера паролей LastPass раскрыли еще одну любопытную деталь прошлогоднего взлома инфраструктуры компании (официальное сообщение статья в издании Ars Technica, коротко на Хабре). Как выяснилось, организаторы атаки успешно взломали компьютер DevOps-инженера, который оказался одним из четырех человек в команде с доступом к ключам шифрования от бэкапов, хранившихся в облачном сервисе Amazon S3. Именно так атакующим удалось получить доступ к пользовательским данным. Как мы писали ранее, попавшие в руки злоумышленников пользовательские данные зашифрованы отдельно с помощью пользовательского же мастер-пароля, но ряд метаданных (например, URL веб-сайтов, на которых LastPass сохранял данные форм) хранился в открытом виде. Преступники взломали домашний компьютер инженера, который он в том числе использовал для рабочих задач. Они воспользовались уязвимым приложением, получили возможность выполнять произвольный код и установили кейлоггер. А через него украли мастер-пароль к корпоративной учетке в сервисе LastPass и хранившимся в ней ключам шифрования. По данным Ars Technica, полученным из анонимного источника, уязвимым приложением был медиасервер Plex. Что это была за уязвимость — непонятно, разработчики самого Plex сообщили, что LastPass с ними по поводу данного инцидента не связывались.В сообщении компании ESET говорится о распространении буткита, способного обходить ограничения системы Secure Boot. Буткит распространяется в составе вредоносного ПО BlackLotus и, по данным компании, способен атаковать даже полностью пропатченные компьютеры под управлением Windows 11. Буткит эксплуатирует уязвимость CVE-2022-21894 , пропатченную в январе 2022 года. Проблема в том, что уязвимые исполняемые файлы с корректной цифровой подписью так и не были добавлены в список программ , запрещенных для выполнения при инициализации UEFI.'https://habr.com/share/publication/720708/83e0fe0ddd8377748e08eb06d08aece5/'"['https://habrastorage.org/getpro/habr/company/8a6/991/272/8a69912727889ab6bdd5244d5f2e4a2c.png', 'https://habrastorage.org/getpro/habr/avatars/fe4/0e2/2a9/fe40e22a957a2624684a47d3da2d924f.png', 'https://habrastorage.org/r/w780q1/webt/bl/f0/g1/blf0g1sdjtk47k8apgefj4kjo9q.jpeg', 'https://habr.com/share/publication/720708/83e0fe0ddd8377748e08eb06d08aece5/', 'https://mc.yandex.ru/watch/24049213', 'https://habrastorage.org/r/w32/getpro/habr/avatars/fe4/0e2/2a9/fe40e22a957a2624684a47d3da2d924f.png']"
13'720808'Мониторинг СМИ по заданным вопросам при помощи открытых источников'Всем привет! В этой статье мы рассмотрим как организовать свой собственный мониторинг СМИ по интересующим вопросам. Научимся формировать RSS-потоки [ 1 ] и настраивать сбор данных, познакомимся с...'https://habr.com/ru/post/720808/'"Всем привет! В этой статье мы рассмотрим как организовать свой собственный мониторинг СМИ по интересующим вопросам. Научимся формировать RSS-потоки [ 1 ] и настраивать сбор данных, познакомимся с популярными решениями для чтения RSS-лент, а также улучшим свои навыки построения поисковых запросов для Google, он же Гугл Доркинг. Итак, поехали!

DISCLAIMER: Внимание! Вся изложенная информация предназначена для ознакомления. Автор не несет никакой ответственности за причиненный вред с использованием представленной информации.

Сбор данных. Формирование RSS-потока

Организацию мониторинга СМИ начнем со сбора данных, который можно реализовать при помощи бесплатного сервиса Google Alerts [ 2 ]. Открыв сервис, в поле ввода текста вбиваем поисковый запрос, а в настройках (Нажимаем на кнопку «Еще параметры») задаем источники (Новости, Блоги, Интернет, Видео и т.д.), язык и страну поисковой выдачи, количество результатов, а также способ доставки – RSS-фид. Теперь нажимаем кнопку «Создать оповещение» и на выходе получаем гиперссылку RSS-канала. Далее необходимо ее скопировать и вставить в cвой любимый RSS-ридер.

Если же тебе не по душе Google, то можешь воспользоваться RSS-генераторами. Например, RSS.app [ 3 ], FetchRSS [ 4 ], mySitemapGenerator [ 5 ] или PolitePol [ 6 ]. Стоит отметить, что перечисленные веб-сервисы могут генерировать RSS-фиды не только из поисковой выдачи Google, но и по контенту выбранных тобою веб-сайтов. Таким образом ты можешь организовать свою систему наблюдения определенных тем, событий или новостей в популярных поисковиках или настроить сбор появления всех записей от необходимых СМИ. Делается это с помощью Гугл Дорков.

Сбор данных. Гугл Дорки

Тема Гугл Дорков настолько обширна, что для нее нужно писать отдельную статью. Поэтому мы коснемся ее частично, «по верхам», затронем только самую необходимую часть для организации собственного мониторинга СМИ.

Ниже представлен список операторов Google, которые помогут в достижении твоей цели.

1. Двойные кавычки (“пример поискового запроса”)

Ищет точные совпадения с фразой, заключенной в двойные кавычки.

Пример: «Tom Hunter» [ 7 ]

2. Логическое ИЛИ (OR или |)

Ищет по Х или У. Возвращает результаты, связанные с Х или У, или и то, и другое.

Пример: Tom OR Hunter | Tom Hunter [ 8 ]

3. Оператор отрицания (–)

Исключает слово, стоящее после оператора отрицания, из поисковой выдачи.

Пример: tomhunter -tom -hunter [ 9 ]

4. Круглые или квадратные скобки («()» или «[]»)

Скобки нужны для группировки нескольких слов, терминов или операторов, чтобы контролировать поисковую выдачу.

Пример: (tom OR hunter) OR tomhunter [ 10 ]

5. Символ астериска (*)

Символ астериска используется в качестве подстановочного знака для произвольной фразы или слова.

Пример: t*hunter [ 11 ]

6. Оператор site:

Выдает результаты для определенного домена.

Пример: site:tomhunter.ru [ 12 ]

7. Оператор intitle:

Ищет страницы с определенным словом в заголовке страницы.

Пример: intitle:tomhunter [ 13 ]

8. Оператор allintitle:

Аналогично оператору «intitle:», но возвращает результаты со всеми указанными словами в теге title.

Пример: allintitle:tom hunter tomhunter [ 14 ]

9. Оператор inurl:

Ищет страницы с определенным словом в URL.

Пример: inurl:tomhunter [ 15 ]

10. Оператор allinurl:

Аналогично оператору «inurl:», но возвращает результаты со всеми указанными словами в URL.

Пример: allinurl:tom hunter tomhunter [ 16 ]

11. Оператор intext:

Ищет страницы, в содержании которых есть определенное слово.

Пример: intext:tomhunter [ 17 ]

12. Оператор allintext:

Аналогично оператору «intext:», но возвращает результаты со всеми указанными словами на странице.

Пример: allintext:tom hunter tomhunter [ 18 ]

Перечисленных операторов Google вполне хватит на создание Гугл Дорков для использования в твоем кастомном мониторинге СМИ по заданным вопросам.

Мониторинг. Выбор RSS-ридера

После сбора интересующей информации ее необходимо как-то читать и анализировать. В этом деле поможет RSS-ридер (или RSS–агрегатор) – это десктопная программа, веб-сервис, мобильное приложение или расширение браузера для автоматического сбора информации в форматах RSS или Atom и последующего предоставления ее пользователю.

Приведем некоторые примеры различного программного обеспечения для чтения RSS-лент:

1. Feedly [ 19 ]. Знаменитый RSS и блог агрегатор, доступный в виде мобильных приложений под ОС Android и iOS, расширения браузера и веб-сервиса.

2. FeedReader [ 20 ]. Минималистичный и элегантный RSS-ридер. Существует в виде десктопной программы и веб-версии.

3. Feedbro [ 21 ]. RSS-агрегатор в виде расширения браузера для Chrome, поддерживающий источники в форматах RSS, Atom или RDF.

4. Start.me [ 22 ]. «Читалкой» RSS-фидов может быть и популярный конструктор стартовых страниц. Просто, быстро и удобно.

5. Inoreader [ 23 ]. Интересный ридер с возможностью фильтрации RSS-фидов по заданным правилам. Агрегатор доступен в виде веб-сервиса и на мобильных телефонах под управлением ОС Android, iOS и Windows Phone.

6. FileForFiles & SiteSputnik [ 24 ]. Отдельного упоминания стоит платный программный комбайн по автоматизации и организации профессионального поиска, сбора, мониторинга и анализа информации.

Мониторинг. Социальные сети

Организовать мониторинг СМИ можно и по социальным сетям. Технологии дают возможность следить по определенным темам, сайтам, группам, людям, каналам или СМИ следующими способами:

1. Гугл Доркинг. Составляем необходимый запрос в Google, автоматизируем сбор данных с помощью Google Alerts или RSS-генератора и получаем искомую информацию.

Пример поискового запроса: site:tomhunter.ru news [ 25 ]

2. На базе Google создаем свой кастомный поисковик по социальным сетям [ 26 ]. При желании также можно автоматизировать сбор данных с помощью RSS-генератора.

3. Веб-сервис Social-Searcher [ 27 ]. Помогает найти веб-сайты, учетные записи и посты журналистов в социальных сетях по различным параметрам. Больше подходит для поиска по западным соцсетям.

4. Приложение TweetDeck [ 28 ] можно использовать для наблюдения за интересующими учетными записями, хештегами и темами в социальной сети Twitter в формате удобного дашборда.

5. Также можно воспользоваться RSS-генератором для Telegram каналов. Добавляем в свой любимый RSS-ридер гиперссылку на интересующий канал. Например, https://rsshub.app/telegram/channel/tomhunter . Меняем название канала «tomhunter» на искомый и пользуемся.

Пример организации мониторинга СМИ по заданным вопросам

Теперь после теории перейдем к практике. На примере покажем, как можно организовать свой собственный кастомный мониторинг средств массовой информации.

1. Определимся с интересующей темой и источниками. Например, тема – «Финансы», источники – весь домен верхнего уровня RU.

2. Составим Гугл Дорк, который позволит найти информацию по упомянутой теме:

site:ru (""финансы"" OR ""экономика"" OR ""финансовые новости"" OR ""акции"" OR ""фондовый рынок"" OR ""Финансы в IT"")

3. Воспользуемся веб-сервисом Google Alerts для генерации RSS-фида.

4. В качестве RSS-ридера воспользуемся конструктором стартовых страниц start.me.

И готово! Вот таким нехитрым образом возможно организовать свой мониторинг средств массовой информации по любым вопросам и темам."'https://habrastorage.org/getpro/habr/upload_files/682/413/afc/682413afccbee57bd8ecaf7aa0a2be4b.PNG'"['https://habrastorage.org/r/w1560/getpro/habr/upload_files/c52/b21/5dd/c52b215dd2c3ae4407e4122813639cdf.png', 'https://habrastorage.org/r/w1560/getpro/habr/upload_files/9a7/85c/bd0/9a785cbd0be2867f7eb45686f379f7c7.png', 'https://habrastorage.org/getpro/habr/upload_files/682/413/afc/682413afccbee57bd8ecaf7aa0a2be4b.PNG', 'https://habrastorage.org/r/w780q1/getpro/habr/upload_files/d1c/97f/b52/d1c97fb52b0f9dbbfc2a038be629203b.jpeg', 'https://habrastorage.org/r/w780q1/getpro/habr/upload_files/289/2f7/091/2892f7091c4d3d34fa1b8e0f6cd1c386.jpeg', 'https://habrastorage.org/r/w1560/getpro/habr/upload_files/eac/ccd/ac6/eacccdac63a6ac8adcf44c340bd25d2b.png', 'https://habrastorage.org/getpro/habr/avatars/686/5ba/c86/6865bac86ac48418021a30758ebcfa95.jpg', 'https://habrastorage.org/r/w1560/getpro/habr/upload_files/9f2/11a/c21/9f211ac21dc4111029469f6243934361.png', 'https://habrastorage.org/r/w1560/getpro/habr/upload_files/dac/5c1/e3a/dac5c1e3acc469cdef256c402ed8e91b.png', 'https://habrastorage.org/r/w1560/getpro/habr/upload_files/200/286/22e/20028622e09bbabadef49de8bcc4746c.png', 'https://habrastorage.org/r/w1560/getpro/habr/upload_files/6d1/09f/5e1/6d109f5e16787c99a640296ca9532d89.png', 'https://habrastorage.org/r/w780q1/getpro/habr/upload_files/987/a09/079/987a09079b759d2990071af333f61b0c.jpeg', 'https://mc.yandex.ru/watch/24049213', 'https://habrastorage.org/getpro/habr/company/d58/c75/748/d58c75748e9334c5fb203c0e61c41e45.jpg', 'https://habrastorage.org/getpro/habr/upload_files/65b/dd6/775/65bdd6775d37a7c016267aa35269b927.gif', 'https://habrastorage.org/r/w1560/getpro/habr/upload_files/5f4/ceb/086/5f4ceb0862140cb566cba2c124af317f.png', 'https://habrastorage.org/r/w1560/getpro/habr/upload_files/34a/3fc/28e/34a3fc28ef9c5440fd36a438173fb6fc.png', 'https://habrastorage.org/r/w1560/getpro/habr/upload_files/fa2/b76/748/fa2b767480e5d1b4e6d4a7810971bb4e.png', 'https://habrastorage.org/r/w32/getpro/habr/avatars/686/5ba/c86/6865bac86ac48418021a30758ebcfa95.jpg']"
14'720800'True RND или что делать с обученной моделью (опыт чайника)'Когда то давно на просторах интернета читал статью о генерации по настоящему случайного пароля. Суть сводилась к тому что для реализации рандома нужно натурально бросать игральные кости. Отличная...'https://habr.com/ru/post/720800/'"Когда то давно на просторах интернета читал статью о генерации по настоящему случайного пароля. Суть сводилась к тому что для реализации рандома нужно натурально бросать игральные кости. Отличная идея, для небольшого pet проекта и для того чтобы проникнуть в основы ML.

Попробуем научить компьютер бросать настоящие кости, находить их на изображении с веб камеры и понимать что на них выпало. И так, из подручных материалов делаем стенд для бросания костей.

Я выбрал двадцатигранные кости, хотя это не принципиально.

Подключаем aduino к драйверу и соленоиду тормоза, Далее arduino слушает команды на rs232, отключает тормоз и включает двигатель либо наоборот.

скетч int drive = 11; int brake = 10; void setup() { Serial.begin(9600); Serial.setTimeout(5); } void loop() { if (Serial.available()) { int val = Serial.parseInt(); if (val == 123) { digitalWrite(brake, LOW); digitalWrite(drive, HIGH); } if (val == 234) { digitalWrite(brake, HIGH); digitalWrite(drive, LOW); } } }

Для начала нужно создать датасет. На любом языке делаем программку которая отправляет на RS232 команды бросить кости, а затем сохраняет кадр с камеры. Получаюем такие картинки:

Делаем разметку. Для этого я накидал программку, которая по координатам трех точек строит окружность, находит координаты ее центра. Далее кликаем мышкой в углы костей, и сохраняем вместе с именем файла в csv. Но после разметки 700 картинок я понял, надо что то менять.

Зайдем с другой стороны. На размеченных картинках вырезаем круглые области с костями, сохраняем их в png, так как нам не нужно все что вне окружности, сразу раскладываем по папкам в соответствии с выпавшими цифрами. Делаем несколько фоток без костей. Далее просто размещаем в случайных местах на фоновой картинке 3 случайные кости. Тут нужно учесть что кости не могут пересекаться и должны находится внутри стакана.

Таким образом создаем 100000 картинок, сохраняя разметку.

Не забываем про главную формулу ML: shit in = shit out

Поэтому оценим получившийся датасет при помощи простой модельки на базе Xception.

baseline base_model = Xception(weights='imagenet', include_top=False, input_shape = [480, 640, 3]) base_model.trainable = True #Устанавливаем новую «голову» (head): x = base_model.output x = GlobalAveragePooling2D()(x) #Pooling слой x = BatchNormalization()(x) #добавим Batch нормализацию x = Dense(256, activation='relu')(x) # полносвязный слой с активацией relu x = Dropout(0.25)(x) # полносвязный слой с вероятность отключения нейронов в слое output = Dense(6, name=out_key)(x) model = Model(inputs=base_model.input, outputs=output)

На выходе модели 6 чисел, соответствующих координатам центров костей. Проверил на реальных картинках, процентов 80 распозналось как то так:

остальные как то так:

Вывод: синтетический датасет вполне пригоден для обучения. Далее обучим Yolo3. За основу возьмем эту реализацию. Реализаций много, но тех которые работают из коробки мало.

Результат: мы молодцы, обучили классную модель, которая классно находит кости и... все. А что с ней делать дальше? Как ее ""установить"" своей бабушке?

Нужно дружить ее, например с C# и делать нормальное приложение с юзерфрендли интерфейсом. Есть несколько вариантов чтобы подружить модель с C#. Рассмотрим ONNX. Итак, конвертируем модель, в в формат onnx. Далее смотрим в гугле или ютубе туториал например этот. Пробуем повторить и... код не работает. Но работоспособность кода запечетлена на видео! Смотрим очень внимательно и устанавливаем именно те версии библиотек. Теперь работает.

Но модель ничего не видит. Предполагаем что C# скармливает картинку сетке не так как Python. Проверим.

Для этого сделаем маленькую сетку, которая будет принимать на вход картинку 3*3 а на выход просто выдавать 27 цифр соответствующих цветам пикселей.

тестовая модель input = Input(shape=[IMG_SIZE, IMG_SIZE, IMG_CHANNELS], name='image') output = Flatten()(input) model = tf.keras.models.Model(input, output)

Подадим ей на вход синюю картинку в Python и C#, сравним результаты:

Видим что в отличие от Python`а C# извлекает сначала все байты одного цвета, потом второго и третьего.

Укажем в экстракторе пикселей что не надо так, а заодно укажем правильный порядок цветов.

код ... .Append(context.Transforms.ExtractPixels(outputColumnName: ""image"", orderOfExtraction: ImagePixelExtractingEstimator.ColorsOrder.ABGR, colorsToExtract: ImagePixelExtractingEstimator.ColorBits.Rgb, interleavePixelColors: true ))

Ну вот теперь, модель видит все как положено. Вернемся к версии библиотек. Если верить тому что тут написано микрософт решила убрать поддержку Bitmap, потому что эта сущность есть только в виндовс. В замен предлагают использовать MLImage. Обожаю когда авторы меняют интерфейсы. Давайте попробуем. И когда мы передаем модельке картинку загруженную из файла: MLImage.CreateFromFile(String) то проблем действительно нет.

Но мы хотим вебкамеру, в реальном времени, еще и не просто смотреть а рисовать в каждом кадре. В гугле много примеров как работать с вебкой при помощи Emgu.CV. И что больше всего подкупает они работают без танцев с бубном.

Кадры с вебкамеры Emgu.CV извлекает в обьекты тыпа Mat. По сути это просто матрица, в нашем случае байтов. MLImage можно создать из линейного массива байтов: CreateFromPixels(Int32, Int32, MLPixelFormat, ReadOnlySpan<Byte>).

Вытягиваем наш Mat и пробуем создать MLImage.

код Mat m = new Mat(); webcam.Retrieve(m); Bitmap img = m.ToImage<Bgr, byte>().ToBitmap(); byte[] barray = new byte[img.Width*img.Height*3]; m.CopyTo(barray); MLImage image = MLImage.CreateFromPixels(img.Width, img.Height, MLPixelFormat.Bgra32, barray);

Bitmap здесь создается только для вывода в pictureBox. Запускаем и модель ничего не видит. Снова смотрим как передаются данные, и проблема в том что формат пикселя у MLImage всегда содержит альфа слой, а Mat с камеры приходит без него. Добавляем альфу:

код Mat m = new Mat(); webcam.Retrieve(m); Bitmap img = m.ToImage<Bgr, byte>().ToBitmap(); CvInvoke.CvtColor(m, m, ColorConversion.Bgr2Bgra); byte[] barray = new byte[img.Width*img.Height*4]; m.CopyTo(barray); MLImage image = MLImage.CreateFromPixels(img.Width, img.Height, MLPixelFormat.Bgra32, barray);

и получаем то к чему стремились:

PS. Большая часть кода в проекте взята из указанных источников почти без изменений, либо с незначительной подгонкой, здесь я указал лишь не очевидные моменты. Если будут интересны подробности, пишите."'https://habr.com/share/publication/720800/d97d6d29f41dfe42bb7ff276de3a31a5/'"['https://habrastorage.org/r/w780q1/getpro/habr/upload_files/8dc/c80/827/8dcc80827c13a9e73a7f5e26177ee58b.jpg', 'https://habrastorage.org/r/w1560/getpro/habr/upload_files/5a6/1d3/31e/5a61d331e0cca4b9a475869dcf71b084.png', 'https://habrastorage.org/r/w780q1/getpro/habr/upload_files/78f/53e/45e/78f53e45e04ec0e3a370a91e5de633f1.jpg', 'https://habrastorage.org/r/w780q1/getpro/habr/upload_files/b0e/ca3/ba4/b0eca3ba402eaf8a2f20d9bf6ab8821a.jpg', 'https://habrastorage.org/r/w1560/getpro/habr/upload_files/a8d/529/283/a8d529283a122c2d479622bdf677837f.png', 'https://mc.yandex.ru/watch/24049213', 'https://habrastorage.org/r/w780q1/getpro/habr/upload_files/42c/ca7/f21/42cca7f214b38188a7e863023686b259.jpg', 'https://habrastorage.org/r/w780q1/getpro/habr/upload_files/61d/a1a/9c3/61da1a9c3493b5074c8d5a15d1612bba.jpg', 'https://habr.com/share/publication/720800/d97d6d29f41dfe42bb7ff276de3a31a5/', 'https://habrastorage.org/r/w780q1/getpro/habr/upload_files/838/27b/4e2/83827b4e22ffc23b755262ff7d8ba4a8.jpg']"
15'720794'Spring-потрошитель: жизненный цикл Spring Framework'Введение Ни для кого не секрет, что Spring Framework один из самых популярных фреймворков для приложений на языке Java. Он интегрировал в себя самые полезные и актуальные технологии, такие как i18n,...'https://habr.com/ru/post/720794/'"Введение

Ни для кого не секрет, что Spring Framework один из самых популярных фреймворков для приложений на языке Java. Он интегрировал в себя самые полезные и актуальные технологии, такие как i18n, JPA, MVC, JMS, Cloud и т.п.

Но насколько хорошо вы знакомы с жизненным циклом фреймворка? Наверняка вы сталкивались с проблемами поднятия контекста и освобождением ресурсов при его остановке, когда проект разрастается. Сегодня я попытаюсь наглядно показать вам это.

Я решил изучить эту тему так как официальная документация достаточно разбросано отвечает на этот вопрос. В итоге я разработал небольшой тестовый стенд. Для тестирования я использовал специальные интерфейсы интеграции и аннотации которые позволяют расширить контейнер Spring-а, которые позволяют внедрить кастомную логику в его жизненный цикл. Я выбрал эти инструменты, так как там обычно и возникают проблемы. Я считаю, что это необходимо знать, чтобы избежать проблем на стадии разработки, отладки и тестирования.

К слову в этой статье не обсуждается почему жизненный цикл такой, какой он есть. Здесь я хочу вам показать результаты моих исследований и выводы. Также здесь не рассматриваются нюансы жизненного цикла иерархических контекстов.

Краткий экскурс

В данном подразделе я кратко расскажу об инструментах интеграции, которые предоставляет Spring. Вы можете пропустить его если вы знакомы со следующими понятиями: IoC Container, DI, BeanDefinition , BeanFactory , ApplicationContext , BeanFactoryPostProcessor , BeanPostProcessor , ApplicationListener , Lifecycle , SmartLifcycle .

Инверсия управления (Inversion of Control) - это принцип, при котором фреймворк вызывает пользовательский код. Это отличается от случая с библиотеками, потому что пользовательский код вызывает код библиотеки.

Внедрение зависимостей (Dependency Injection) - это шаблон проектирования, в котором объект получает объекты, от которых он зависит. Это отделяет создание объектов от их использования.

IoC Контейнер (IoC Container) - это реализация IoC и DI. Контейнер IoC создает и управляет bean-компонентами на основе мета-информации. Он также может решать и предоставлять зависимости для создаваемых им объектов.

BeanDefinition - описывает bean-компоненты. Создается на основе разобранной мета-информации.

BeanFactory - это интерфейс который создает и предоставляет bean-компоненты на основе BeanDefinition-ов. Он является ядром ApplicationContext .

ApplicationContext - это центральный интерфейс который предоставляете следующий список возможностей:

возможности BeanFactory

загрузка ресурсов

публикация событий

интернационализация

автоматическая регистрация BeanPostProcessor и BeanFactoryPostProcessor

BeanFactoryPostProcessor - это интерфейс, который позволяет настраивать определения bean-компонентов контекста приложения. Он создается и запускается перед BeanPostProcessor.

BeanPostProcessor - это интерфейс для обеспечения интеграции кастомной логики создания экземпляров, разрешения зависимостей и т. д. Каждый компонент, созданный BeanFactory , проходит через каждый зарегистрированный BeanPostProcessor .

ApplicationContextEvent - основной класс для событий, возникающих в процессе жизненного цикла ApplicationContext. Его подклассы:

ContextRefreshedEvent - публикуется автоматически после поднятия контекста

ContextStartedEvent - публикуется методом ApplicationContext#start

ContextStoppedEvent - публикуется методом ApplicationContext#stop

ContextClosedEvent - публикуется автоматически перед закрытием контекста

ApplicationListener - интерфейс который позволяет обрабатывать ApplicationEvent события. Можно использовать аннотацию @EventListener вместо интерфейс.

Lifecycle - интерфейс похожий на ApplicationListener , но в нем определено 2 метода, которые срабатывают во время запуск (start) и остановку (stop) контекста.

SmartLifcycle - это расширение Lifecycle интерфейса. Отличие в том, что он срабатывает во время обновление (refresh) и закрытия (close) контекста.

Понимаю, что это может быть немного запутанным. Я постараюсь разложить все по полочкам далее.

Жизненный цикл контекста Spring-а

Жизненный цикл контекста состоит из 4-ёх этапов:

Этап обновления (refresh) - автоматический Этап запуска (start) - вызывается методом ApplicationContext#start Этап остановки (stop) - вызывается методом ApplicationContext#stop Этап закрытия (close) - автоматический

Этап обновления контекста

BeanFactory создает BeanFactoryPostProcessor -ы используя конструктор без аргументов

Стоит знать BeanFactory может создать экземпляр BeanFactoryPostProcessor только с конструктором без аргументов. В противном случае вы получите сообщение об ошибке со следующим сообщением: No default constructor found.

Обратные вызовы инициализации и уничтожения не работают как у обычных bean-компоненты. Хотя он помечен аннотацией @Component . Подробности в Жизненный цикл bean-компонена.

Если вы пометили BeanFactoryPostProcessor как лениво инициализируемый, то BeanFactory проигнорирует это

ApplicationContext вызывает метод BeanFactoryPostProcessor#postProcessBeanFactory BeanFactory creates BeanPostProcessor -ы

Стоит знать `ApplicationContext` позволяет внедрять зависимости в конструктор `BeanPostProcessor`, но такой компонент не будет обрабатываться `BeanPostProcessor` и вы получите следующее сообщение: `Bean someBean is not eligible for getting processed by all BeanPostProcessor interfaces (for example: not eligible for auto-proxying`

Обратные вызовы инициализации и уничтожения работают как обычные bean-компоненты.

ApplicationContext регистрирует BeanPostProcessor -ы Инициализация singleton bean-компонентов. Подробности в Жизненный цикл bean-компонента. ApplicationContext проверяет флаг SmartLifecycle#isRunning и вызывает метод SmartLifecycle#start , если флаг имеет значение false

Стоит знать Метод SmartLifecycle#start вызывается автоматически на этапе обновления (refresh), поскольку флаг SmartLifecycle#isAutoStartup по умолчанию имеет значение true

Метод Lifecycle#start не вызывается на этапе обновления. Он вызывается на этапе запуска (start). Начальная фаза запускается только с помощью ApplicationContext#start .

ApplicationContext публикует ContextRefreshedEvent Методы обратного вызова, помеченные аннотацией @EventListener с типом параметра метода ContextRefreshedEvent , обрабатывают это событие. Также здесь может быть ApplicationListener

Стоит знать Один метод может обрабатывать несколько событий. Например: `@EventListener(classes = { ContextStartedEvent.class, ContextStoppedEvent.class })`

Этап запуска контекста

ApplicationContext проверяет флаг Lifecycle#isRunning и вызывает метод Lifecycle#start , если флаг имеет значение false ApplicationContext проверяет флаг SmartLifecycle#isRunning и вызывает метод SmartLifecycle#start , если флаг имеет значение false. Да-да, контекст второй раз проходиться по объектам реализующие интерфейс SmartLifecycle ApplicationContext публикует ContextStartedEvent Методы обратного вызова, помеченные аннотацией @EventListener с типом параметра метода ContextStartedEvent , обрабатывают это событие. Также здесь может быть ApplicationListener

Этап остановки контекста

ApplicationContext проверяет флаг SmartLifecycle#isRunning и вызывает метод SmartLifecycle#stop , если флаг имеет значение true ApplicationContext проверяет флаг Lifecycle#isRunning и вызывает метод Lifecycle#stop , если флаг имеет значение true ApplicationContext публикует ContextStoppedEvent Методы обратного вызова, помеченные аннотацией @EventListener с типом параметра метода ContextStoppedEvent , обрабатывают это событие. Также здесь может быть ApplicationListener

Этап закрытия контекста

ApplicationContext публикует ContextClosedEvent Методы обратного вызова, помеченные аннотацией @EventListener с типом параметра метода ContextClosedEvent , обрабатывают это событие. Также здесь может быть ApplicationListener ApplicationContext проверяет флаг SmartLifecycle#isRunning и вызывает метод SmartLifecycle#stop , если флаг имеет значение true

Стоит знать Это выполниться раньше если был запущен этап остановки контекста

ApplicationContext проверяет флаг Lifecycle#isRunning и вызывает метод Lifecycle#stop , если флаг имеет значение true

Стоит знать Это выполниться раньше если был запущен этап остановки контекста

Уничтожение bean-компонентов. Подробности в Жизненный цикл bean-компонента

Жизненный цикл bean-компонента

Жизненный цикл bean-компонента состоит из 2-ух этапов:

Этап инициализации Этап уничтожения

Этап инициализации bean-компонента

BeanFactory создает bean-компонент Срабатывает статический блок инициализации Срабатывает не статический блок инициализации Внедрение зависимостей на основе конструктора Внедрение зависимостей на основе setter -ов Отрабатывают методы стандартного набора *Aware интерфейсов BeanPostProcessor#postProcessBeforeInitialization обрабатывает bean-компонент InitDestroyAnnotationBeanPostProcessor#postProcessBeforeInitialization вызывает методы обратного вызова, помеченные аннотацией @PostConstruct BeanFactory вызывает метод InitializingBean#afterPropertiesSet BeanFactory вызывает метод обратного вызова, зарегистрированный как initMethod . BeanPostProcessor#postProcessAfterInitialization() обрабатывает bean-компонент

Этап уничтожения bean-компонента

Этап уничтожения срабатывает только для singleton bean-компонентов, так как только эти компоненты храниться в BeanFactory .

InitDestroyAnnotationBeanPostProcessor.postProcessBeforeDestruction вызывает методы обратного вызова, отмеченные как @PostConstruct BeanFactory вызывает метод InitializingBean#destroy BeanFactory вызывает метод обратного вызова, зарегистрированный как destroyMethod

Стоит знать По умолчанию bean-компоненты, определенные с конфигурацией Java, которые имеют public метод close() или shutdown() , автоматически становятся методами обратного вызова уничтожения.

Дополнения к жизненному циклу

В данном подразделе я кратко расскажу об инструментах, о которых я не рассказывал ранее, так как они позволяют добавить более специфическую логику в жизненный цикл Spring-a. А моя цель была подробно разобрать типичный жизненный цикл.

Ordered - интерфейс, позволяющий управлять порядком работы компонентов. Например, если компоненты реализуют BeanPostProcessor / BeanFactoryPostProcessor и Ordered интерфейсы, то мы можем контролировать порядок их выполнения.

FactoryBean - интерфейс, позволяющий внедрить сложную логику создания объекта. Если у вас есть сложный код инициализации, который лучше выражается на Java, вы можете создать свой собственный FactoryBean , написать сложную инициализацию внутри этого класса, а затем подключить свой собственный FactoryBean к контейнеру.

ApplicationStartup - это инструмент, который помогает понять, на что тратится время на этапе запуска.

Еще существует механизм перезапуска приложения. Это может понадобиться в случаях:

Если нам нужно загрузить измененную мета-информацию

Если нужно изменить текущие активные профили

Если контекст упал и мы хотим иметь возможно автоматически поднять его

Подробнее об этом можно почитать в статье Programmatically Restarting a Spring Boot Application

Заключение

В этой статье мы изучили жизненный цикл Spring Framework, построили четкий алгоритм его работы. Мы изучили инструменты интеграции, которые позволяют использовать жизненный цикл в своих интересах, и выяснили роль каждого инструмента.

Эту статью вы можете использовать для подготовки к собеседованию, или как справочник, когда вы думаете как использовать инструменты Spring-а в своем проекте.

Все проверки я проводил на разработанном мною тестовом стенде, который наглядно показывает алгоритм жизненного цикла с использованием инструментов интеграции предоставляемых Spring Framework-ом.

Также у меня есть репозиторий, который тесно связан с темой этой статьи. Там вы найдете продублированный код из серии выступлений Spring-потрошитель от Евгения Борисова. Я создал этот репозиторий 4 года назад, так что facepalm гарантирую.

Спасибо за внимание и любите друг друга! Теперь это жизненно необходимо.

P.S. Да, я слизал эту фразу у Вовы Ломова ведущего канала Теплица социальных технологий.

Полезные ссылки"'https://habrastorage.org/getpro/habr/upload_files/2d0/3bf/0b9/2d03bf0b95d7f162f7dced020a414235.jpeg'"['https://habrastorage.org/getpro/habr/avatars/131/cf8/a80/131cf8a80082b6dff4a5aa803120e9d4.png', 'https://habrastorage.org/r/w32/getpro/habr/avatars/131/cf8/a80/131cf8a80082b6dff4a5aa803120e9d4.png', 'https://mc.yandex.ru/watch/24049213', 'https://habrastorage.org/getpro/habr/upload_files/2d0/3bf/0b9/2d03bf0b95d7f162f7dced020a414235.jpeg']"
16'720790'Недельный геймдев: #111 — 05 марта, 2023'Из новостей : Godot 4.0, для Blender вышел официальный плагин генератора ИИ-артов Stable Diffusion, Valve обновили правила и рекомендаций по получению ключей, Playtika временно приостановила...'https://habr.com/ru/post/720790/'"Из новостей: Godot 4.0, для Blender вышел официальный плагин генератора ИИ-артов Stable Diffusion, Valve обновили правила и рекомендаций по получению ключей, Playtika временно приостановила разработку новых игр.

Из интересностей: как уменьшить время загрузки вашей игры на 2 секунды+, 22 342 кратное ускорение загрузки геометрии в Unity, Пётр Сальников — гонка от игрожура до геймдева.

Обновления/релизы/новости

Вот и вышел Godot 4.0

После более чем 3 лет перестройки с нуля, полного пересмотра ядра и переписывания движка, 17 альфа-версий, 17 бета-версий и 6 кандидатов на выпуск, команда наконец-то релизнула ожидаемую многими новую версию Godot. Подробнее про 4.0 можно почитать в отдельном посте.

Для Blender вышел официальный плагин генератора ИИ-артов Stable Diffusion

Расширение бесплатно и позволяет гораздо легче экспериментировать с проектами.

Valve обновили правила и рекомендаций по получению ключей

Не то, чтоб прям что-то новое, ограничения на выдачу уже несколько лет как есть. Можно сравнить с архивной версией. Моментики:

Максимум 2,500 Release State Override (beta) ключей до релиза для целей краудфандинга.

До 5 тысяч стандартных ключей для распространения в других магазинах. Раньше тоже много не выдавали, но явного ограничений в правилах не было.

Добавили текст о том, что при обработке запросов на выдачу смотрят на разные критерии: уровень интереса покупателей в Steam, число уже запрошенных и активированных ключей и т. д.

Уточнили по поводу продажи в других местах, чтоб «сделка не была лучше, чем для пользователей внутри Steam’а».

Playtika временно приостановила разработку новых игр

CFO сказал, что это продлится до тех пор, «пока окупаемость новых игр не станет экономически оправданной».

Жалуются, что CPI слишком вырос. Вот только не уверен, что в ближайшее время он упадёт 😅

Rust GameDev #42: январь 2023

Очередная подборка геймдев раст-сообщества.

Valve обновили Steam Mature Content Survey и пред-релизные проверки

Обновления должны упростить процесс подготовки к выпуску и помочь клиентам лучше понять природу вашей игры.

Халява/раздачи/бандлы/курсы

Пакеты ресурсов Control Rig и Mannequin теперь доступны для аниматоров

Для начинающих аниматоров это отличный способ, чтобы получить непосредственный опыт работы с процедурной анимацией и анимацией в реальном времени в Unreal Engine.

Интересные статьи/видео

Как уменьшить время загрузки вашей игры на 2 секунды+

Довольно простые мелочи, но могут помочь вашей игре.

Как EBB Software интегрировала плагин Unreal Engine для FSR 2.1

Разработчики Scorn поделились техническими подробностями интеграции новой технологии AMD.

22 342 кратное ускорение загрузки геометрии в Unity

Занимательная история, хотя и немного странноватая. Но интересно было почитать про оптимизацию OBJ файлов.

Создание охотничьего лагеря в черепе дракона с помощью ZBrush и Unreal Engine

Антонио Браво рассказал о проекте Hunting Camp, показал, как создавалась голова дракона, и поведал о настройке освещения.

Как художнику интерпретировать мир вокруг и совершенствовать зрительные образы

Доклад 3D‑художника Конрада Джастина расшифровала команда Скилбокс.

Следим за памятью с помощью нового пакета Memory Profiler

В посте команда Unity рассмотрела пять ключевых рабочих моментов в новом пакете Memory Profiler, которые вы можете использовать для диагностики и изучения проблем, связанных с памятью, в вашей игре.

Дизайн экономики и баланса 4Х-стратегии

В первой статье цикла речь пойдёт о подготовке системы ситибилдинга.

Советы по поиску работы от Techland

Главный рекрутер Techland Михал Пенкала объяснил, как справиться с потерей работы, поделился некоторыми советами по созданию портфолио, которые помогут быстрее найти новую, и дал советы художникам, желающим присоединиться к Techland.

Сохранение европейского королевского наследия с помощью RealityCapture и Unreal Engine

Такие организации, как Artzenal из Словакии, предоставляющая полный спектр услуг в области цифрового искусства, от ранних 2D-набросков до высококачественного 3D-контента и изображений персонажей, приступают к реализации проектов по сохранению культуры, чтобы помочь сохранить историю.

Как Against the Storm удалось совместить градостроительство и роглайт

Игра сочетает в себе элементы роглайта и ситибилдер, предлагая игрокам строить и процветать, несмотря на неизбежные бедствия.

Совместимость 3D-контента с моделированием без топологии

Современное программное обеспечение для моделирования на основе топологии создаёт трехмерные объекты с одним уровнем детализации. Это делает их неработоспособными с метавселенной. Кроме того, из-за процесса создания топологии 3D-моделирование занимает много времени и имеет высокий входной барьер для создания контента.

Участник программы NVIDIA Inception Program и нью-йоркский стартап Shapeyard решает проблему совместимости 3D-контента метавселенной, автоматизируя создание топологии с несколькими уровнями детализации при экспорте или потоковой передаче.

Пётр Сальников — гонка от игрожура до геймдева

Легенда отечественной игровой сферы в гостях у Лавалампы и унижает сони-эксклюзивы (¬‿¬ ).

Дизайн уровней. Учимся у Atomic Heart

Небольшой разбор отдельных аспектов игры.

Как изобретаются новые жанры

Немного аналитики с реальными примерами.

Интервью с одним из разработчиков игр инди-студии Creepy Brothers

Не так давно на Хабре уже был материал про инди-студию Baba Yaga Games, потом про мобильных разработчиков Black Caviar Games. На очереди студия разработки, которая существует уже 13 лет — это студия Creepy Brothers.

Death of a Game: Gwent

Разбор самостоятельной игры от CDPR, которая выросла из мини-игры Ведьмака 3.

Коммуникация как сердце игры-головоломки

В посте ведущий гейм-дизайнер Eleven Puzzles Майри Нолан рассказывает о том, как команда построила коммуникацию в своем последнем релизе Unsolved Case, и о важности вербального взаимодействия в игре.

Дизайн уровней. Методы создания секретов и бонусов

Небольшая статья с примерами по левел-дищайну.

Кейс Playrix и почему соответствие продукта рынку является движущейся целью

Аналитический пост от deconstructoroffun, вдохновлённый подходом Playrix к User Acquisition.

Вращение по кругу объектов в blender с помощью нод

В статье автор показывает как сделать вращение по кругу объектов в blender, используя геометрические ноды.

Как делать арт игры в Midjourney

Автор начал создавать практически весь арт для своей инди-игры с помощью Midjourney. В статье он показал как игра выглядит сейчас, какой арт создаётся, и рассказал как это делает.

Рабочая культура и процесс найма в Sierra Division

Джейкоб Норрис рассказал, как компания определяет, над какими проектами работать, объяснил организацию рабочих процессов в Sierra Division и дал ряд полезных советов художникам, желающим начать свой путь в студии.

Замена цветов

В статье представлен обзор различных методов настройки цветов объектов.

Показано, как реализовать представленные методы с использованием языка визуальных шейдеров Unity, а также в HLSL.

Разное

Процедурный генератор карты

Из Твиттера.

Немного базы для инди-разработчиков

Без негатива (RESPECTFULLY) 🤭

Bloodborne в Unreal Engine 5

Разработчик пытается воссоздать игру на последней версии движка Эпиков.

Анимация дверей в The Last of Us Part II

Максим Журавлов показал реалистичную анимацию взаимодействия игрока с дверью в TLoU Part II от Naughty Dog.

Если хотите поддержать выход дайджеста и других материалов, сделать это можно одним из способов."'https://habrastorage.org/getpro/habr/upload_files/935/cd0/7f5/935cd07f50e2770fd9d58ba1dabb8528.png'"['https://habrastorage.org/r/w780q1/getpro/habr/upload_files/e35/a71/109/e35a711096b46a40fe5c1d12887f65ad.jpeg', 'https://habrastorage.org/r/w780q1/getpro/habr/upload_files/dd2/860/b3a/dd2860b3a9f82d2002da0733f5a8ce62.jpeg', 'https://habrastorage.org/r/w780q1/getpro/habr/upload_files/dbd/092/037/dbd0920379915249a325eedb501ffa88.jpeg', 'https://habrastorage.org/r/w780q1/getpro/habr/upload_files/5c6/771/a23/5c6771a23b9de5e9f1bda277e043cd56.jpeg', 'https://habrastorage.org/getpro/habr/upload_files/421/2e0/998/4212e09984881bc008ebbee34fda9068.gif', 'https://habrastorage.org/getpro/habr/upload_files/935/cd0/7f5/935cd07f50e2770fd9d58ba1dabb8528.png', 'https://habrastorage.org/r/w1560/getpro/habr/upload_files/643/a34/844/643a348447e35b73027efdd64363c92d.png', 'https://habrastorage.org/r/w1560/getpro/habr/upload_files/0af/2bd/fd9/0af2bdfd90a7ed2197f0783e277c03f4.png', 'https://habrastorage.org/r/w780q1/getpro/habr/upload_files/eab/606/28b/eab60628bca4389e44a1a39689ca99e7.jpeg', 'https://habrastorage.org/r/w1560/getpro/habr/upload_files/ce5/be5/e8c/ce5be5e8c85f2785b168edf9ee4d2d0e.png', 'https://habrastorage.org/r/w1560/getpro/habr/upload_files/d74/1c6/78f/d741c678f4ee4d9f5ab6a057f9f7e2ff.png', 'https://habrastorage.org/r/w780q1/getpro/habr/upload_files/a60/fd6/479/a60fd64796c73d58bf2ce032f5b2ef5f.jpeg', 'https://habrastorage.org/r/w1560/getpro/habr/upload_files/211/2b2/23b/2112b223b211bd4f1a469defed45092c.png', 'https://habrastorage.org/r/w780q1/getpro/habr/upload_files/efd/9aa/1a2/efd9aa1a2df7adceac270c157456e910.jpeg', 'https://habrastorage.org/r/w780q1/getpro/habr/upload_files/df7/ceb/83b/df7ceb83b6022214963089c919e857f2.jpeg', 'https://habrastorage.org/r/w780q1/getpro/habr/upload_files/ad2/cdc/f4e/ad2cdcf4e8ffbb01a939934f2e29d02e.jpeg', 'https://habrastorage.org/r/w32/getpro/habr/avatars/78c/a06/c52/78ca06c52b5e82548aa9083df9d104ea.jpg', 'https://habrastorage.org/r/w1560/getpro/habr/upload_files/264/eee/cf3/264eeecf3a20119dc200282c55c6ca35.png', 'https://habrastorage.org/r/w1560/getpro/habr/upload_files/7b8/6da/4d7/7b86da4d7db4f54c8254faebc8caa402.png', 'https://habrastorage.org/r/w1560/getpro/habr/upload_files/549/135/e9a/549135e9aa849874a5210bf80460f5ac.png', 'https://habrastorage.org/r/w1560/getpro/habr/upload_files/b5b/a56/60f/b5ba5660f4db588a9a5393b0d47022bd.png', 'https://habrastorage.org/r/w1560/getpro/habr/upload_files/fb9/d9f/53a/fb9d9f53a04293e42768c544a34bc4d9.png', 'https://habrastorage.org/r/w780q1/getpro/habr/upload_files/dc6/6ae/ed4/dc66aeed477edfc02ca500f947c22adc.jpeg', 'https://habrastorage.org/r/w780q1/getpro/habr/upload_files/f5f/58e/f16/f5f58ef166585eca51db1230852c28cb.jpeg', 'https://mc.yandex.ru/watch/24049213', 'https://habrastorage.org/r/w1560/getpro/habr/upload_files/16f/d87/cc8/16fd87cc8c7d1a61b366d770a0af0021.png', 'https://habrastorage.org/getpro/habr/avatars/78c/a06/c52/78ca06c52b5e82548aa9083df9d104ea.jpg', 'https://habrastorage.org/r/w1560/getpro/habr/upload_files/cdc/60a/b27/cdc60ab27131efae836c1eeb345fe9bd.png', 'https://habrastorage.org/r/w1560/getpro/habr/upload_files/935/cd0/7f5/935cd07f50e2770fd9d58ba1dabb8528.png', 'https://habrastorage.org/r/w1560/getpro/habr/upload_files/79b/92d/d2b/79b92dd2be044f8bbeeacf48c29fa92e.png', 'https://habrastorage.org/r/w1560/getpro/habr/upload_files/1db/29d/805/1db29d805988a8c308313aa0a5023978.png', 'https://habrastorage.org/r/w1560/getpro/habr/upload_files/18e/41e/132/18e41e13241195c3a302d52d9a189098.png', 'https://habrastorage.org/getpro/habr/upload_files/6fc/759/04a/6fc75904a471fb0f30d2e77c760f38b2.gif', 'https://habrastorage.org/r/w780q1/getpro/habr/upload_files/e1a/6bf/a57/e1a6bfa5783ccad74a5a35f525d49da3.jpeg', 'https://habrastorage.org/r/w1560/getpro/habr/upload_files/cce/0dd/c1b/cce0ddc1b86fa2f46951898d48be0e8d.png']"
17'720724'Книга «Внутри CPYTHON: гид по интерпретатору Python»'Привет, Хаброжители! CPython, самая популярная реализация Python, абстрагируется от сложностей ОС и предоставляет платформу для создания масштабируемых и высокопроизводительных приложений. Каждому...'https://habr.com/ru/post/720724/'"Энтони Шоу — заядлый питонист, участник Python Software Foundation. Энтони занимался программированием с 12 лет. Любовь к Python он обрел спустя 15 лет, когда ему пришлось какое-то время просидеть в отеле в Сиэттле (штат Вашингтон). С тех пор Энтони исследует Python, пишет о нем и создает учебные курсы, забыв обо всех остальных языках, которые он прежде изучал. Энтони также участвует в малых и больших проектах с открытым исходным кодом, включая CPython, и является участником Apache Software Foundation. Страсть Энтони — разбираться в сложных системах, упрощать их и обучать других людей.

Джим Андерсон давно программирует на разных языках. Он работал над встроенными системами, разрабатывал распределенные системы сборки, занимался управлением сторонними исполнителями и участвовал во многих, многих собраниях.



Джоанна Яблонски — редактор сайта Real Python. Естественные языки интересуют ее не меньше, чем языки программирования. Ее любовь к головоломкам, поиску закономерностей и всевозможным мелочам привела к тому, что она выбрала карьеру переводчика. Прошло совсем немного времени, и она влюбилась в новый язык — Python! Джоанна присоединилась к команде Real Python в 2018 году и с тех пор помогает питонистам повышать их профессиональный уровень.



Джейкоб Шмитт уже много лет занимается редактированием академических и технологических образовательных материалов — как в печатном виде, так и в интернете. После присоединения к команде Real Python в 2020 году он редактирует учебники, статьи и книги, написанные разносторонней командой талантливых писателей и разработчиков.

"'https://habr.com/share/publication/720724/7393e6dd178f6ab8a86cb6770724e809/'"['https://habrastorage.org/r/w780q1/webt/xc/do/o0/xcdoo0_jnvwvdwbicqmayq5jm40.jpeg', 'https://habrastorage.org/r/w1560/webt/7s/-o/_h/7s-o_hmpuldlcq4ffcwh05w7yws.png', 'https://habrastorage.org/getpro/habr/company/e4d/50a/630/e4d50a630923dbf6e6b786d26b9da6d7.png', 'https://habrastorage.org/r/w1560/webt/w3/jn/6z/w3jn6zjtbk0x0egsdlv7quiz1x8.png', 'https://habrastorage.org/r/w1560/webt/a3/ih/nk/a3ihnkca6zwi5ibql0aiw8z8gxy.png', 'https://habrastorage.org/r/w1560/webt/sa/nk/vf/sankvftkbb89fhmdhis4tj-ifbg.png', 'https://habrastorage.org/r/w1560/webt/z3/vc/8v/z3vc8vriq5zd6cfq9shqaar13-4.png', 'https://habr.com/share/publication/720724/7393e6dd178f6ab8a86cb6770724e809/', 'https://habrastorage.org/getpro/habr/avatars/3be/b11/2b0/3beb112b076924a916b27c845d88dcfa.jpg', 'https://habrastorage.org/r/w32/getpro/habr/avatars/3be/b11/2b0/3beb112b076924a916b27c845d88dcfa.jpg', 'https://mc.yandex.ru/watch/24049213', 'https://habrastorage.org/r/w1560/webt/jh/-e/gs/jh-egsqwkfei7gjdi6xujxvj24g.png']"
18'720788'Небезопасный android: эксперименты с sun.misc.Unsafe. Часть 1'Java очень глубоко интегрирована в android и имеет в данной ОС свою нестандартную виртуальную машину — Dalvik VM, поэтому многие детали реализации отличаются от привычных. А что насчёт внутреннего...'https://habr.com/ru/post/720788/'"Java очень глубоко интегрирована в android и имеет в данной ОС свою нестандартную виртуальную машину — Dalvik VM, поэтому многие детали реализации отличаются от привычных. А что насчёт внутреннего API sun.misc.Unsafe? В этом цикле статей с его помощью мы попытаемся максимально сломать виртуальную машину андроида.

Содержание Часть 1. Введение. Создание arrayCast и немного про его применение

Введение

Начать стоит с того, что данный класс из себя представляет и для чего обычно используется. sun.misc.Unsafe существует с очень ранних версий java и необходим для выполнения действий, которые не предусмотрены языком, а их реализация в нативном коде по каким-то причинам нежелательна. Какие же возможности он предоставляет?

Object allocateInstance(Class<?> cls) — создание объекта, без вызова конструктора. Все поля заполняются стандартными значениями (0, 0.0, null и т.п.)

XXX getXXX(Object obj, long offset) — чтение памяти, используя объект как указатель. Если он равен null, то смещение выступает в качестве нативного адреса

void setXXX(Object obj, long offset, XXX value) — запись в память по тем же правилам, что и при чтении

int arrayBaseOffset(Class<?> cls), int arrayIndexScale(Class<?> cls) — определение параметров массива (смещение от начала массива до первого элемента и размер элементов соответственно)

long allocateMemory(long bytes), void freeMemory(long address) — обёртки над malloc и free из Си — выделение и освобождение памяти вне кучи

void throwException(Throwable th) — «скрытное» бросание исключений (без их объявления в throws). Увы, но данный метод отсутствует в Unsafe андроида, поэтому придётся создавать его самостоятельно

А так же куча других полезных вещей, особенно для многопоточного программирования, которые в данный момент нам не нужны

Подготовка

Как получить доступ ко всему этому инструментарию? Класс Unsafe содержит публичный метод getUnsafe, только вот незадача — в нём есть проверка безопасности:

public final class Unsafe { <...> private static final Unsafe theUnsafe = new Unsafe(); <...> @CallerSensitive public static Unsafe getUnsafe() { Class<?> caller = Reflection.getCallerClass(); // Этот код не даёт получить экземпляр ползовательским классам if (!VM.isSystemDomainLoader(caller.getClassLoader())) throw new SecurityException(""Unsafe""); return theUnsafe; } <...> }

Один из способов обойти её — прямой доступ к статическому полю theUnsafe через рефлексию

public static Unsafe getUnsafe() { try { // получаем поле Field field = Unsafe.class.getDeclaredField(""theUnsafe""); // делаем его доступным для использования field.setAccessible(true); // получаем экземпляр sun.misc.Unsafe return (Unsafe) field.get(null); } catch (Exception e) { throw new RuntimeException(e); } }

Этот код настолько часто используется в разнообразных библиотеках, что его можно назвать классическим. Он даже не вызывает предупреждений во время выполнения (а вот доступ к конструктору вместо поля — ещё как).

Теперь нужно восполнить отсутствие метода throwException с помощью сломанного класса Thrower — мы создадим в нём метод с нужной сигнатурой, и насильно удалим throws Throwable:

Реализация Вариант кода на Smali — ассемблере Dalvik: .class public Lcom/v7878/Thrower; .super Ljava/lang/Object; .method public constructor <init>()V .registers 1 invoke-direct { p0 }, Ljava/lang/Object;-><init>()V return-void .end method .method public static throwException(Ljava/lang/Throwable;)V .registers 1 throw p0 .end method То же самое, но на java: // Не скомпилируется,так как нет throws Throwable public class Thrower { public static void throwException(Throwable th) { throw th; } }

Эксперименты

Время перейти к самому интересному, тому, ради чего затевалась статья — экспериментам.

arrayCast

Что произойдёт если мы попробуем обратиться к объекту класса A как к объекту класса B, например попытаемся вызвать метод или получить поле, которого у него нет? Язык защищает от таких поступков ещё на этапе компиляции, и не даёт нам творить беспредел, но ведь теперь мы можем это игнорировать, да? Обмануть компилятор (а заодно и верификатор байт-кода) можно положив объект в поле неправильного типа и обращаясь уже к нему:

// Смещение от начала массива до первого элемента // int ARRAY_OBJECT_BASE_OFFSET = arrayBaseOffset(Object[].class); class A { public int a; } class B { public int b; } A obj = new A(); obj.a = 100; B[] array = new B[1]; // array[0] = obj; putObject(array, ARRAY_OBJECT_BASE_OFFSET, obj); System.out.println(array[0].b); // System.out: 100

В данном примере мы положили объект типа A (со значением 100 в поле a) как первый элемент массива B и получили значение 100 из поля b. Как это произошло?

Объяснение Объект java представляет собой ссылку на память в куче, где лежат его данные — поля. Каждое поле имеет своё смещение от начала объекта (они отсортированы по уменьшению размера и по алфавиту. Сначала идут поля суперкласса). Например класс java.lang.Object имеет всего 2 поля: public class Object { <...> private transient Class<?> shadow$_klass_; private transient int shadow$_monitor_; <...> } shadow$_klass_ содержит тип объекта, а shadow$_monitor_ данные монитора (используется для методов wait* и notify* и блоков synchronized) и/или кешированый хешкод. Первое поле будет иметь смещение 0 и размер 4 (размер поля не примитивного типа на андроиде равен 4 (даже на 64-битных устройствах!)), второе поле — смещение 4 и такой же размер. Переходя к изначальному примеру — поле a типа A имеет то же самое смещение, что и поле b типа B, поэтому доступ ко второму даёт первое. Обратите внимание, что ни один объект не сменил реальный тип.

Теперь можно обобщить полученный опыт и сделать отдельный метод, выполняющий функцию оператора reinterpret_cast из C++

// Смещение от начала массива до первого элемента // int ARRAY_OBJECT_BASE_OFFSET = arrayBaseOffset(Object[].class); // размер элемента массива объектов (на андроиде всегда должен быть 4) // int ARRAY_OBJECT_INDEX_SCALE = arrayIndexScale(Object[].class); public <T> T[] arrayCast(Class<T> clazz, Object... data) { // нам нужен массив объектов, а не чего-то ещё if(clazz.isPrimitive()) { throw new IllegalArgumentException(); } // создаём массив типа T T[] out = (T[]) Array.newInstance(clazz, data.length); // переносим все объекты в массив for (int i = 0; i < data.length; i++) { putObject(out, ARRAY_OBJECT_BASE_OFFSET + i * ARRAY_OBJECT_INDEX_SCALE, data[i]); } return out; }

Свежеиспечённый метод принимает класс, к которому мы хотим привести группу объектов, и сами объекты, кладёт их в массив нужного типа и возвращает. Удивительно, но андроид ни разу не проверяет, что именно лежит в массиве, поэтому всё проходит гладко.

Теперь давайте применим arrayCast для изменения private final поля, чего нельзя сделать с помощью обычной рефлексии:

class A { private final int value; public A(int value) { this.value = value; } @Override public String toString() { return Integer.toString(value); } } class B { public int value; } A obj = new A(100); // приводим obj к типу B B[] array = arrayCast(B.class, obj); // меняем значение array[0].value = -1; // выводим в консоль System.out.println(obj); // System.out: -1

Получается, что при известном строении объекта с его полями можно творить что угодно, но как насчёт методов?

class A { private final int value; public A(int value) { this.value = value; } @Override public String toString() { return Integer.toString(value); } } class B { public int value; public void set(int x) { value = x; } } A obj = new A(100); // приводим obj к типу B B[] array = arrayCast(B.class, obj); // меняем значение array[0].set(-1); // выводим в консоль System.out.println(obj); // ожидаем получить: System.out: -1 // получаем: zygote A [runtime.cc:492] Runtime aborting... // и огромный столб текста с аварийным дампом

Что произошло? Почему такие ужасные последствия у, казалось бы, маленьких изменений? Причина кроется в способе вызова методов — по индексу в списке внутри класса объекта. Мы вызываем метод B.set(int), допустим он имеет индекс 1, но вызываем то мы его на объекте типа A! У него другой список, и под индексом 1, может быть, идёт конструктор. Это несоответствие и вызывает ошибку.

Но почему такого не происходит при доступе к полям? Ответ прост — они всегда имеют постоянное смещение и его нет нужды вычислять каждый раз по индексу поля в классе, а значит, для оптимизации всегда идёт прямой доступ по заранее просчитанному смещению.

В будущем мы периодически будем обращаться к arrayCast для достижения своих целей. На этом вводная часть подходит к концу.

*Продолжение следует*

Весь исходный код можно найти здесь."'https://habr.com/share/publication/720788/4135b1f54354aae1a5ea808c50f58c9a/'"['https://habrastorage.org/r/w32/getpro/habr/avatars/a60/6fa/146/a606fa146a2b32a60e2b2a729833f02a.jpg', 'https://habr.com/share/publication/720788/4135b1f54354aae1a5ea808c50f58c9a/', 'https://habrastorage.org/r/w1560/getpro/habr/upload_files/c34/ebd/185/c34ebd18544a7a2f5c02721c785ad680.png', 'https://mc.yandex.ru/watch/24049213', 'https://habrastorage.org/getpro/habr/avatars/a60/6fa/146/a606fa146a2b32a60e2b2a729833f02a.jpg']"
19'719666'KC868-AK: пианино на DIN-рейку (собачий вальс теперь не проблема)'Неуёмный креатив наших китайских друзей из компании Kincony достиг таких масштабов, что даже я, хорошо знакомый почти со всей их продукцией, иногда впадаю в ступор от их изобретений. Когда я первый...'https://habr.com/ru/post/719666/'"❯ KC868-AK

❯ Функциональное назначение

❯ Технические характеристики

Микроконтроллер ESP32 (ESP-WROOM-32E)

35 физических кнопок (матрица 7х5)

36 цифровых опторазвязанных входов («сухой контакт»)

Интерфейс RS232

Интерфейс RS485

Отдельный I2C разъём

Отдельный разъём FreeGPIO (4 пина)

Разъём USB для программирования и заливки прошивок

Кнопки «Reset» и «Download»

2 программируемых светодиода

Светодиод наличия питания

Питание от 12/24 В постоянного тока

❯ Внешний вид

❯ Схемотехника

Цифровые входы и кнопки

Разъём I2C интерфейса

Разъём FreeGPIO

❯ Распиновка KC868-AK

❯ Схема внешних подключений

❯ Заключение

Неуёмный креатив наших китайских друзей из компании Kincony достиг таких масштабов, что даже я, хорошо знакомый почти со всей их продукцией, иногда впадаю в ступор от их изобретений.Когда я первый раз увидел KC868-AK (креатив начинается прямо с индекса), то долго пытался понять что это и зачем это нужно. Рассматривание фотографий и чтение описаний мало что добавляло к пониманию назначения изделия. Тут и клавиатура на 35 кнопок, и цифровые входы, и проводные интерфейсы и ESP32 — что это вообще? и как это можно применять?Некоторое понимание добавило ознакомление со схемой изделия, его разборка и осмотр обратной стороны его печатной платы. Что же это такое, для чего это можно применить и как это работает мы и попробуем разобраться далее…Как выяснилось в последствии, KC868-AK — это ни что иное, как… контроллер! Это не клавиатура, не беспроводная клавиатура, а именно полноценный ESP32 контроллер, у которого клавиатура, хоть доминирует визуально, является только небольшой «подсистемой» его обширного функционала, характерного для контроллеров на ESP32.Другими словами, KC868-AK нужно воспринимать не как «клавиатуру», а именно как полноценный контроллер на ESP32, но с дополнительными возможностями по «кнопочному» управлению вашей IoT системой.Тут нужно понимать и различать две вещи: то, что представляет собой KC868-AK с «железной» точки зрения, как ESP32 контроллер общего назначения и то, как видит его использование производитель.Это две совершенно разные вещи:Сам по себе KC868-AK — это ESP32 контроллер общего назначения, который мы можем как угодно программировать и как угодно использовать в своих проектах в составе IoT систем. Для нас это основной режим использования KC868-AK и в этом для нас основной смысл его применения.Производитель (компания Kincony) совершенно по другому видит использование KC868-AK: она создавала этот контроллер в первую очередь для управления своими (мощными и функциональными) контроллерами различных серий, например, контроллером KC868-H32B PRO. Для работы в этом режиме, KC868-AK имеет специализированную прошивку с веб-интерфейсом, которая позволяет настраивать работу входов и логику управления другими контроллерами.Как я уже заметил, для нас второй режим (который является основным и дефолтным с точки зрения Kincony) не имеет особого смысла: у нас нет парка контролеров наподобие Kincony KC868-H32B PRO, да и сама прошивка, насколько она ни была бы хороша, нам не очень интересна, поскольку, владея программированием, мы сами можем создать нужную нам (в каждом конкретном случае) прошивку.Ниже представлена схема типового использования KC868-AK, с точки зрения производителя.Поскольку мы «сами себе программисты», то всё дальнейшее повествование я буду посвящать «железному» устройству KC868-AK и режиму самостоятельного его программирования. Обзору фирменной прошивки можно будет посвятить отдельную статью.Теперь давайте познакомимся с техническими характеристиками контроллера KC868-AK.Исходя из всего вышесказанного, мы имеем контроллер на ESP32 со всеми присущими ему возможностями, 36 цифровых входов с «запараллеленными» 35-ю кнопками и двумя проводными интерфейсами — RS232 и RS485.Весь этот потенциал можно использовать «как угодно», в соответствии с потребностями ваших проектов, но, если использовать его «по прямому назначению», то вырисовывается такая схема:К контроллеру KC868-AK на цифровые входы подсоединяются различные выключатели и сенсоры (в соответствии с вашим проектом), части физических кнопок на его борту приписываются какие-то функции, которыми можно будет оперативно управлять, нажимая на эти кнопки, и всё это хозяйство интегрируется в вашу общую IoT систему при помощи доступных интерфейсов: RS232, RS485, Wi-Fi и т. д.Колпачки кнопок снимаются и могут быть заменены на нужные вам. Вообще, логичным выглядит сделать специализированные для вашей задачи (проекта) колпачки (возможно прямоугольной формы) с нужными надписями и пиктограммами, а также не помешал бы какой-то шильдик (передняя панель) для этих кнопок.В целом, с KC868-AK всё более-менее понятно, теперь давайте поближе познакомимся с его «железом».О вкусах не спорят, но о внешнем виде KC868-AK одно можно можно сказать определённо — это произведение искусства несомненно украсит ваш строгий щиток и вызовет неподдельную зависть у коллег-автоматизаторов и заинтересованное внимание детей и женщин.Кстати, может быть компании-производителю стоит несколько изменить концепцию устройства и сделать по углам платы отверстия для крепления, а все разъёмы перенести на нижнюю сторону платы. Тогда KC868-AK V2.0 можно будет легко встраивать в любые корпуса различных агрегатов — получится встраиваемая управляющая панель.KC868-AK без крепления на DIN-рейку и в компании с нашим старым знакомым Norvi Сёмой.Вид сверху. Всё сделано в узнаваемом фирменном стиле контроллеров Kincony. Всё чистенько, ровненько, плюс традиционный набор разъёмов. Отдельно радует то, что Kincony прислушалась к нашим советам и стала выводить на плату разъёмы I2C и FreeGPIO.Вот оно всё где, оказывается, прячется: почти все элементы распаяны на нижней стороне печатной платы KC868-AK.Далее я не буду приводить принципиальные схемы всех подсистем контроллера, ограничусь только решениями, характерными для KC868-AK.Большую часть контроллера занимает подсистема цифровых входов и кнопок. Как вы видите, цифровые входы и кнопки запараллеленны, что определяет возможные варианты их использования.Контроллер имеет 36 цифровых оптоизолированных входов «сухой контакт» на оптронах EL357, распределённых на 4 колодки по 9 контактов. Для обеспечения их работы в связке с ESP32 в KC868-AK применены расширители цифровых входов/выходов c I2C интерфейсом на 5-и микросхемах PCF8574P.Чтобы не загромождать схему, показан только один блок из 8-и оптронов и их обвязки, остальные подобные блоки полностью ему аналогичны. Расширители портов на PCF8574P показаны все 5 штук.Очень ценный разъём для модернизации и подключения различного оборудования к контроллеру. Можно добавить датчики, дисплей и т. д.Не менее ценный разъём с четырьмя свободными GPIO, к которым можно подключить различное дополнительное оборудования. Тут можно сказать «хорошо, но мало» — ниже будет показана распиновка KC868-AK, на которой будет видно, что куча GPIO ESP32 на этом контроллере не используется и нет никаких причин не вывести их отдельный разъём на плате.Почему этого не сделано? Ответ только один: Kincony производит контроллеры, но не делает реальные проекты и просто не имеет представления о полезности выведения свободных пинов в разъёмы на плате.Распиновка KC868-AK. Куча свободных пинов ESP32, на которые можно было бы повесить какие-то дополнительные компоненты на плате контроллера, или хотя бы вывести их в отдельный разъём, чтобы пользователь имел возможность самостоятельно их использовать.Оригинальная схема разъёмов и внешних подключений контроллера KC868-AK. Разъёмы, контакты, элементы, номера кнопок и т. д.Назначение светодиодов указаны для фирменной прошивки. В нашем случае самостоятельного программирования, мы можем как угодно их использовать и задавать им функции индикации любых событий в системе.В общем, KC868-AK можно использовать как контроллер на ESP32 с цифровыми входами и интерфейсами RS232, RS485 и Wi-Fi или как управляющую панель в каких-то проектах, где необходимо оперативное «кнопочное» управление самим контроллером или другими контроллерами вашей «умной IoT системы»."'https://habrastorage.org/webt/rs/qo/gx/rsqogxwdareadccbbckdn_iv7ey.jpeg'"['https://habrastorage.org/getpro/habr/company/fc0/4f0/3f7/fc04f03f7188eca615ef971283d62dc5.png', 'https://habrastorage.org/r/w1560/webt/w6/v3/c2/w6v3c2vu6tn2esnry4zjkvke4ym.png', 'https://habrastorage.org/webt/rs/qo/gx/rsqogxwdareadccbbckdn_iv7ey.jpeg', 'https://habrastorage.org/r/w780q1/webt/s9/ek/ki/s9ekkiavzua6probeonxsuxf49a.jpeg', 'https://habrastorage.org/r/w780q1/webt/xs/mo/tu/xsmotur3g-fawuvgqjgfdstlcq8.jpeg', 'https://habrastorage.org/r/w1560/webt/m5/ct/yx/m5ctyxxu9zcw0wzom7mvk32lqlg.png', 'https://habrastorage.org/r/w1560/webt/3h/6q/yj/3h6qyjeivggspbplyeyscbum2se.png', 'https://habrastorage.org/r/w780q1/webt/4y/4b/t_/4y4bt_ihk4ebfzopxvirwil27sg.jpeg', 'https://habrastorage.org/r/w1560/webt/tm/wh/yh/tmwhyhe0zesb_uoimthyclf8vy8.png', 'https://habrastorage.org/r/w1560/webt/-8/9e/d8/-89ed8zrx49ol_sbp0r4mskkr5s.png', 'https://habrastorage.org/r/w780q1/webt/b0/y2/lj/b0y2ljypo4jwkjycnyjqwqbxzpe.jpeg', 'https://mc.yandex.ru/watch/24049213', 'https://habrastorage.org/r/w780q1/webt/fu/2e/9y/fu2e9ycpkhrdaznevrmpikxxpcs.jpeg', 'https://habrastorage.org/r/w780q1/webt/rs/qo/gx/rsqogxwdareadccbbckdn_iv7ey.jpeg', 'https://habrastorage.org/r/w780q1/webt/ju/iv/_w/juiv_wakuovdtbnl42fycl1de9c.jpeg']"
